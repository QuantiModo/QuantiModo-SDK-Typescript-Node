import request = require('request');
import promise = require('bluebird');
import http = require('http');

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class AggregatedCorrelation {
    /**
    * id
    */
    id: number;
    /**
    * Pearson correlation coefficient between cause and effect measurements
    */
    correlation: number;
    /**
    * variable ID of the cause variable for which the user desires correlations
    */
    causeId: number;
    /**
    * variable ID of the effect variable for which the user desires correlations
    */
    effectId: number;
    /**
    * User estimated or default time after cause measurement before a perceivable effect is observed
    */
    onsetDelay: number;
    /**
    * Time over which the cause is expected to produce a perceivable effect following the onset delay
    */
    durationOfAction: number;
    /**
    * Number of points that went into the correlation calculation
    */
    numberOfPairs: number;
    /**
    * cause value that predicts an above average effect value (in default unit for cause variable)
    */
    valuePredictingHighOutcome: number;
    /**
    * cause value that predicts a below average effect value (in default unit for cause variable)
    */
    valuePredictingLowOutcome: number;
    /**
    * Optimal Pearson Product
    */
    optimalPearsonProduct: number;
    /**
    * Vote
    */
    vote: number;
    /**
    * Number of Users by which correlation is aggregated
    */
    numberOfUsers: number;
    /**
    * Number of Correlations by which correlation is aggregated
    */
    numberOfCorrelations: number;
    /**
    * A function of the effect size and sample size
    */
    statisticalSignificance: number;
    /**
    * Unit of the predictor variable
    */
    causeUnit: string;
    /**
    * Unit ID of the predictor variable
    */
    causeUnitId: number;
    /**
    * Cause changes
    */
    causeChanges: number;
    /**
    * Effect changes
    */
    effectChanges: number;
    /**
    * Aggregated QM Score
    */
    aggregateQmScore: number;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
    /**
    * Status
    */
    status: string;
    /**
    * Error Message
    */
    errorMessage: string;
    /**
    * Last Successful update time
    */
    lastSuccessfulUpdateTime: Date;
    /**
    * Correlation when cause and effect are reversed. For any causal relationship, the forward correlation should exceed the reverse correlation
    */
    reversePearsonCorrelationCoefficient: number;
    /**
    * Predictive Pearson Correlation Coefficient
    */
    predictivePearsonCorrelationCoefficient: number;
    /**
    * Source of data for this correlation
    */
    dataSource: string;
}

export class Correlation {
    /**
    * id
    */
    id: number;
    /**
    * Time at which correlation was calculated
    */
    timestamp: number;
    /**
    * ID of user that owns this correlation
    */
    userId: number;
    /**
    * Pearson correlation coefficient between cause and effect measurements
    */
    correlation: number;
    /**
    * variable ID of the cause variable for which the user desires correlations
    */
    causeId: number;
    /**
    * variable ID of the effect variable for which the user desires correlations
    */
    effectId: number;
    /**
    * User estimated or default time after cause measurement before a perceivable effect is observed
    */
    onsetDelay: number;
    /**
    * Time over which the cause is expected to produce a perceivable effect following the onset delay
    */
    durationOfAction: number;
    /**
    * Number of points that went into the correlation calculation
    */
    numberOfPairs: number;
    /**
    * cause value that predicts an above average effect value (in default unit for cause variable)
    */
    valuePredictingHighOutcome: number;
    /**
    * cause value that predicts a below average effect value (in default unit for cause variable)
    */
    valuePredictingLowOutcome: number;
    /**
    * Optimal Pearson Product
    */
    optimalPearsonProduct: number;
    /**
    * Vote
    */
    vote: number;
    /**
    * A function of the effect size and sample size
    */
    statisticalSignificance: number;
    /**
    * Unit of the predictor variable
    */
    causeUnit: string;
    /**
    * Unit ID of the predictor variable
    */
    causeUnitId: number;
    /**
    * Cause changes
    */
    causeChanges: number;
    /**
    * Effect changes
    */
    effectChanges: number;
    /**
    * QM Score
    */
    qmScore: number;
    /**
    * error
    */
    error: string;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
    /**
    * Correlation when cause and effect are reversed. For any causal relationship, the forward correlation should exceed the reverse correlation
    */
    reversePearsonCorrelationCoefficient: number;
    /**
    * Predictive Pearson Correlation Coefficient
    */
    predictivePearsonCorrelationCoefficient: number;
}

export class MeasurementValue {
    /**
    * When the measurement event occurred . Use ISO 8601 datetime format
    */
    startTime: string;
    /**
    * Value for the measurement
    */
    value: number;
    /**
    * An optional note the user may include with their measurement
    */
    note: string;
}

export class MeasurementPost {
    /**
    * ID of the variable for the measurement as obtained from the GET variables endpoint
    */
    variableId: number;
    /**
    * Source ID of the app or device as obtained from the GET sources endpoint
    */
    sourceId: number;
    /**
    * Unit id for the measurement value as obtained from the GET units endpoint
    */
    unitId: number;
    /**
    * measurements
    */
    measurements: Array<MeasurementValue>;
}

export class CommonVariableRelationship {
    /**
    * id
    */
    id: number;
    /**
    * Our confidence that a consistent predictive relationship exists based on the amount of evidence, reproducibility, and other factors
    */
    confidenceLevel: string;
    /**
    * A quantitative representation of our confidence that a consistent predictive relationship exists based on the amount of evidence, reproducibility, and other factors
    */
    confidenceScore: number;
    /**
    * Direction is positive if higher predictor values generally precede higher outcome values. Direction is negative if higher predictor values generally precede lower outcome values.
    */
    direction: string;
    /**
    * duration_of_action
    */
    durationOfAction: number;
    /**
    * error_message
    */
    errorMessage: string;
    /**
    * User estimated (or default number of seconds) after cause measurement before a perceivable effect is observed
    */
    onsetDelay: number;
    /**
    * Variable ID for the outcome variable
    */
    outcomeVariableId: number;
    /**
    * Variable ID for the predictor variable
    */
    predictorVariableId: number;
    /**
    * ID for default unit of the predictor variable
    */
    predictorUnitId: number;
    /**
    * A value representative of the relevance of this predictor relative to other predictors of this outcome.  Usually used for relevancy sorting.
    */
    sinnRank: number;
    /**
    * A value represented to the size of the effect which the predictor appears to have on the outcome.
    */
    strengthScore: number;
    /**
    * Can be weak, medium, or strong based on the size of the effect which the predictor appears to have on the outcome relative to other variable relationship strength scores.
    */
    strengthLevel: string;
    /**
    * Number of users who feel that there is a plausible causal relationship between the predictor and outcome variables.
    */
    upVotes: number;
    /**
    * Number of users who do not feel that there is a plausible causal relationship between the predictor and outcome variables.
    */
    downVotes: number;
    /**
    * Value for the predictor variable (in it's default unit) which typically precedes an above average outcome value
    */
    valuePredictingHighOutcome: number;
    /**
    * Value for the predictor variable (in it's default unit) which typically precedes a below average outcome value
    */
    valuePredictingLowOutcome: number;
    /**
    * Number of users whose data was aggregated to obtain this relationship
    */
    numberOfUsers: number;
    /**
    * Source of data for this common variable relationship
    */
    dataSource: string;
}

export class Connection {
    /**
    * id
    */
    id: number;
    /**
    * ID of user that owns this correlation
    */
    userId: number;
    /**
    * The id for the connector data source for which the connection is connected
    */
    connectorId: number;
    /**
    * Indicates whether a connector is currently connected to a service for a user.
    */
    connectStatus: string;
    /**
    * Error message if there is a problem with authorizing this connection.
    */
    connectError: string;
    /**
    * Time at which an update was requested by a user.
    */
    updateRequestedAt: Date;
    /**
    * Indicates whether a connector is currently updated.
    */
    updateStatus: string;
    /**
    * Indicates if there was an error during the update.
    */
    updateError: string;
    /**
    * The time at which the connector was last successfully updated.
    */
    lastSuccessfulUpdatedAt: Date;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class Connector {
    /**
    * Connector ID number
    */
    id: number;
    /**
    * Lowercase system name for the data source
    */
    name: string;
    /**
    * Pretty display name for the data source
    */
    displayName: string;
    /**
    * URL to the image of the connector logo
    */
    image: string;
    /**
    * URL to a site where one can get this device or application
    */
    getItUrl: string;
    /**
    * Short description of the service (such as the categories it tracks)
    */
    shortDescription: string;
    /**
    * Longer paragraph description of the data provider
    */
    longDescription: string;
    /**
    * Set to 1 if the connector should be returned when listing connectors
    */
    enabled: boolean;
    /**
    * Set to 1 if the connector uses OAuth authentication as opposed to username/password
    */
    oauth: boolean;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class Credential {
    /**
    * ID of user that owns this credential
    */
    userId: number;
    /**
    * The id for the connector data source from which the credential was obtained
    */
    connectorId: number;
    /**
    * Attribute name such as token, userid, username, or password
    */
    attrKey: string;
    /**
    * Encrypted value for the attribute specified
    */
    attrValue: string;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class Measurement {
    /**
    * id
    */
    id: number;
    /**
    * ID of user that owns this measurement
    */
    userId: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * The id for the connector data source from which the measurement was obtained
    */
    connectorId: number;
    /**
    * ID of the variable for which we are creating the measurement records
    */
    variableId: number;
    /**
    * Application or device used to record the measurement values
    */
    sourceId: number;
    /**
    * Start Time for the measurement event. Use ISO 8601
    */
    startTime: string;
    /**
    * The value of the measurement after conversion to the default unit for that variable
    */
    value: number;
    /**
    * The default unit for the variable
    */
    unitId: number;
    /**
    * Value of measurement as originally posted (before conversion to default unit)
    */
    originalValue: number;
    /**
    * Unit ID of measurement as originally submitted
    */
    originalUnitId: number;
    /**
    * Duration of the event being measurement in seconds
    */
    duration: number;
    /**
    * An optional note the user may include with their measurement
    */
    note: string;
    /**
    * Latitude at which the measurement was taken
    */
    latitude: number;
    /**
    * Longitude at which the measurement was taken
    */
    longitude: number;
    /**
    * location
    */
    location: string;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
    /**
    * error
    */
    error: string;
}

export class MeasurementExport {
    /**
    * id
    */
    id: number;
    /**
    * ID of User
    */
    userId: number;
    /**
    * Status of Measurement Export
    */
    status: string;
    /**
    * Error message
    */
    errorMessage: string;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class Source {
    /**
    * id
    */
    id: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * Name of the application or device
    */
    name: string;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class Unit {
    /**
    * id
    */
    id: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * Unit name
    */
    name: string;
    /**
    * Unit abbreviation
    */
    abbreviatedName: string;
    /**
    * Unit category ID
    */
    categoryId: number;
    /**
    * Minimum value permitted for this unit
    */
    minimumValue: number;
    /**
    * Maximum value permitted for this unit
    */
    maximumValue: number;
    /**
    * updated
    */
    updated: number;
    /**
    * ID of default unit for this units category
    */
    defaultUnitId: number;
    /**
    * Value multiplied to convert to default unit in this unit category
    */
    multiply: number;
    /**
    * Value which should be added to convert to default unit
    */
    add: number;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class UnitCategory {
    /**
    * id
    */
    id: number;
    /**
    * Unit category name
    */
    name: string;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class UnitConversion {
    /**
    * unit_id
    */
    unitId: number;
    /**
    * step in the conversion process
    */
    stepNumber: boolean;
    /**
    * 0 is add and 1 is multiply
    */
    operation: boolean;
    /**
    * number used in the operation
    */
    value: number;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class Update {
    /**
    * id
    */
    id: number;
    /**
    * user_id
    */
    userId: number;
    /**
    * connector_id
    */
    connectorId: number;
    /**
    * number_of_measurements
    */
    numberOfMeasurements: number;
    /**
    * success
    */
    success: boolean;
    /**
    * message
    */
    message: string;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class UserVariable {
    /**
    * ID of the parent variable if this variable has any parent
    */
    parentId: number;
    /**
    * User ID
    */
    userId: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * ID of variable
    */
    variableId: number;
    /**
    * ID of unit to use for this variable
    */
    defaultUnitId: number;
    /**
    * Minimum reasonable value for this variable (uses default unit)
    */
    minimumAllowedValue: number;
    /**
    * Maximum reasonable value for this variable (uses default unit)
    */
    maximumAllowedValue: number;
    /**
    * Value for replacing null measurements
    */
    fillingValue: number;
    /**
    * The Variable this Variable should be joined with. If the variable is joined with some other variable then it is not shown to user in the list of variables
    */
    joinWith: number;
    /**
    * How long it takes for a measurement in this variable to take effect
    */
    onsetDelay: number;
    /**
    * Estimated duration of time following the onset delay in which a stimulus produces a perceivable effect
    */
    durationOfAction: number;
    /**
    * ID of variable category
    */
    variableCategoryId: number;
    /**
    * updated
    */
    updated: number;
    /**
    * Is variable public
    */
    _public: number;
    /**
    * A value of 1 indicates that this variable is generally a cause in a causal relationship.  An example of a causeOnly variable would be a variable such as Cloud Cover which would generally not be influenced by the behaviour of the user
    */
    causeOnly: boolean;
    /**
    * 0 -> No filling, 1 -> Use filling-value
    */
    fillingType: string;
    /**
    * Number of measurements
    */
    numberOfMeasurements: number;
    /**
    * Number of processed measurements
    */
    numberOfProcessedMeasurements: number;
    /**
    * Number of measurements at last analysis
    */
    measurementsAtLastAnalysis: number;
    /**
    * ID of last Unit
    */
    lastUnitId: number;
    /**
    * ID of last original Unit
    */
    lastOriginalUnitId: number;
    /**
    * Last Value
    */
    lastValue: number;
    /**
    * Last original value which is stored
    */
    lastOriginalValue: number;
    /**
    * ID of last source
    */
    lastSourceId: number;
    /**
    * Number of correlations for this variable
    */
    numberOfCorrelations: number;
    /**
    * status
    */
    status: string;
    /**
    * error_message
    */
    errorMessage: string;
    /**
    * When this variable or its settings were last updated
    */
    lastSuccessfulUpdateTime: Date;
    /**
    * Standard deviation
    */
    standardDeviation: number;
    /**
    * Variance
    */
    variance: number;
    /**
    * Minimum recorded value of this variable
    */
    minimumRecordedValue: number;
    /**
    * Maximum recorded daily value of this variable
    */
    maximumRecordedDailyValue: number;
    /**
    * Mean
    */
    mean: number;
    /**
    * Median
    */
    median: number;
    /**
    * Most common Unit ID
    */
    mostCommonUnitId: number;
    /**
    * Most common value
    */
    mostCommonValue: number;
    /**
    * Number of unique daily values
    */
    numberOfUniqueDailyValues: number;
    /**
    * Number of changes
    */
    numberOfChanges: number;
    /**
    * Skewness
    */
    skewness: number;
    /**
    * Kurtosis
    */
    kurtosis: number;
    /**
    * Latitude
    */
    latitude: number;
    /**
    * Longitude
    */
    longitude: number;
    /**
    * Location
    */
    location: string;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
    /**
    * Outcome variables (those with `outcome` == 1) are variables for which a human would generally want to identify the influencing factors.  These include symptoms of illness, physique, mood, cognitive performance, etc.  Generally correlation calculations are only performed on outcome variables
    */
    outcome: boolean;
    /**
    * Comma-separated list of source names to limit variables to those sources
    */
    sources: string;
    /**
    * Earliest source time
    */
    earliestSourceTime: number;
    /**
    * Latest source time
    */
    latestSourceTime: number;
    /**
    * Earliest measurement time
    */
    earliestMeasurementTime: number;
    /**
    * Latest measurement time
    */
    latestMeasurementTime: number;
    /**
    * Earliest filling time
    */
    earliestFillingTime: number;
    /**
    * Latest filling time
    */
    latestFillingTime: number;
}

export class UserVariableRelationship {
    /**
    * id
    */
    id: number;
    /**
    * Our confidence that a consistent predictive relationship exists based on the amount of evidence, reproducibility, and other factors
    */
    confidenceLevel: string;
    /**
    * A quantitative representation of our confidence that a consistent predictive relationship exists based on the amount of evidence, reproducibility, and other factors
    */
    confidenceScore: number;
    /**
    * Direction is positive if higher predictor values generally precede higher outcome values. Direction is negative if higher predictor values generally precede lower outcome values.
    */
    direction: string;
    /**
    * Number of seconds over which the predictor variable event is expected to produce a perceivable effect following the onset delay
    */
    durationOfAction: number;
    /**
    * error_message
    */
    errorMessage: string;
    /**
    * User estimated (or default number of seconds) after cause measurement before a perceivable effect is observed
    */
    onsetDelay: number;
    /**
    * Variable ID for the outcome variable
    */
    outcomeVariableId: number;
    /**
    * Variable ID for the predictor variable
    */
    predictorVariableId: number;
    /**
    * ID for default unit of the predictor variable
    */
    predictorUnitId: number;
    /**
    * A value representative of the relevance of this predictor relative to other predictors of this outcome.  Usually used for relevancy sorting.
    */
    sinnRank: number;
    /**
    * Can be weak, medium, or strong based on the size of the effect which the predictor appears to have on the outcome relative to other variable relationship strength scores.
    */
    strengthLevel: string;
    /**
    * A value represented to the size of the effect which the predictor appears to have on the outcome.
    */
    strengthScore: number;
    /**
    * user_id
    */
    userId: number;
    /**
    * vote
    */
    vote: string;
    /**
    * Value for the predictor variable (in it's default unit) which typically precedes an above average outcome value
    */
    valuePredictingHighOutcome: number;
    /**
    * Value for the predictor variable (in it's default unit) which typically precedes a below average outcome value
    */
    valuePredictingLowOutcome: number;
}

export class Variable {
    /**
    * id
    */
    id: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * ID of the parent variable if this variable has any parent
    */
    parentId: number;
    /**
    * User-defined variable display name
    */
    name: string;
    /**
    * Variable category ID
    */
    variableCategoryId: number;
    /**
    * ID of the default unit of measurement to use for this variable
    */
    defaultUnitId: number;
    /**
    * How to combine values of this variable (for instance, to see a summary of the values over a month) SUM or MEAN
    */
    combinationOperation: string;
    /**
    * Value for replacing null measurements
    */
    fillingValue: number;
    /**
    * Maximum reasonable value for this variable (uses default unit)
    */
    maximumAllowedValue: number;
    /**
    * Minimum reasonable value for this variable (uses default unit)
    */
    minimumAllowedValue: number;
    /**
    * How long it takes for a measurement in this variable to take effect
    */
    onsetDelay: number;
    /**
    * How long the effect of a measurement in this variable lasts
    */
    durationOfAction: number;
    /**
    * Is variable public
    */
    _public: number;
    /**
    * A value of 1 indicates that this variable is generally a cause in a causal relationship.  An example of a causeOnly variable would be a variable such as Cloud Cover which would generally not be influenced by the behaviour of the user
    */
    causeOnly: boolean;
    /**
    * Most common value
    */
    mostCommonValue: number;
    /**
    * Most common Unit
    */
    mostCommonUnitId: number;
    /**
    * Standard Deviation
    */
    standardDeviation: number;
    /**
    * Variance
    */
    variance: number;
    /**
    * Mean
    */
    mean: number;
    /**
    * Median
    */
    median: number;
    /**
    * Number of measurements
    */
    numberOfMeasurements: number;
    /**
    * Number of unique values
    */
    numberOfUniqueValues: number;
    /**
    * Skewness
    */
    skewness: number;
    /**
    * Kurtosis
    */
    kurtosis: number;
    /**
    * status
    */
    status: string;
    /**
    * error_message
    */
    errorMessage: string;
    /**
    * When this variable or its settings were last updated
    */
    lastSuccessfulUpdateTime: Date;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
    /**
    * Product URL
    */
    productUrl: string;
    /**
    * Image URL
    */
    imageUrl: string;
    /**
    * Price
    */
    price: number;
    /**
    * Number of variables
    */
    numberOfUserVariables: number;
    /**
    * Outcome variables (those with `outcome` == 1) are variables for which a human would generally want to identify the influencing factors.  These include symptoms of illness, physique, mood, cognitive performance, etc.  Generally correlation calculations are only performed on outcome variables.
    */
    outcome: boolean;
    /**
    * Minimum recorded value of this variable
    */
    minimumRecordedValue: number;
    /**
    * Maximum recorded value of this variable
    */
    maximumRecordedValue: number;
}

export class VariableCategory {
    /**
    * id
    */
    id: number;
    /**
    * Name of the category
    */
    name: string;
    /**
    * Value for replacing null measurements
    */
    fillingValue: number;
    /**
    * Maximum recorded value of this category
    */
    maximumAllowedValue: number;
    /**
    * Minimum recorded value of this category
    */
    minimumAllowedValue: number;
    /**
    * How long the effect of a measurement in this variable lasts
    */
    durationOfAction: number;
    /**
    * How long it takes for a measurement in this variable to take effect
    */
    onsetDelay: number;
    /**
    * How to combine values of this variable (for instance, to see a summary of the values over a month) 0 for sum OR 1 for mean
    */
    combinationOperation: string;
    /**
    * updated
    */
    updated: number;
    /**
    * A value of 1 indicates that this category is generally a cause in a causal relationship.  An example of a causeOnly category would be a category such as Work which would generally not be influenced by the behaviour of the user
    */
    causeOnly: boolean;
    /**
    * Is category public
    */
    _public: number;
    /**
    * outcome
    */
    outcome: boolean;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
    /**
    * Image URL
    */
    imageUrl: string;
    /**
    * ID of the default unit for the category
    */
    defaultUnitId: number;
}

export class VariableUserSource {
    /**
    * ID of User
    */
    userId: number;
    /**
    * ID of variable
    */
    variableId: number;
    /**
    * ID of source
    */
    sourceId: number;
    /**
    * Time that this measurement occurred Uses epoch minute (epoch time divided by 60)
    */
    timestamp: number;
    /**
    * Earliest measurement time
    */
    earliestMeasurementTime: number;
    /**
    * Latest measurement time
    */
    latestMeasurementTime: number;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class Vote {
    /**
    * id
    */
    id: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * ID of User
    */
    userId: number;
    /**
    * ID of the predictor variable
    */
    causeId: number;
    /**
    * ID of effect variable
    */
    effectId: number;
    /**
    * Value of Vote
    */
    value: number;
    /**
    * When the record was first created. Use ISO 8601 datetime format
    */
    createdAt: Date;
    /**
    * When the record in the database was last updated. Use ISO 8601 datetime format
    */
    updatedAt: Date;
}

export class InlineResponse200 {
    data: Array<AggregatedCorrelation>;
    success: boolean;
}

export class InlineResponse2001 {
    data: AggregatedCorrelation;
    success: boolean;
}

export class InlineResponse2002 {
    data: string;
    success: boolean;
}

export class InlineResponse2003 {
    data: Array<CommonVariableRelationship>;
    success: boolean;
}

export class InlineResponse2004 {
    data: CommonVariableRelationship;
    success: boolean;
}

export class InlineResponse2005 {
    data: Array<Connection>;
    success: boolean;
}

export class InlineResponse2006 {
    data: Connection;
    success: boolean;
}

export class InlineResponse2007 {
    data: Array<Connector>;
    success: boolean;
}

export class InlineResponse2008 {
    data: Connector;
    success: boolean;
}

export class InlineResponse2009 {
    data: Array<Correlation>;
    success: boolean;
}

export class InlineResponse20010 {
    data: Correlation;
    success: boolean;
}

export class InlineResponse20011 {
    data: Array<Credential>;
    success: boolean;
}

export class InlineResponse20012 {
    data: Credential;
    success: boolean;
}

export class InlineResponse20013 {
    data: Array<Measurement>;
    success: boolean;
}

export class InlineResponse20014 {
    data: Measurement;
    success: boolean;
}

export class InlineResponse20015 {
    data: Array<Update>;
    success: boolean;
}

export class InlineResponse20016 {
    data: Array<UserVariable>;
    success: boolean;
}

export class InlineResponse20017 {
    data: Array<Source>;
    success: boolean;
}

export class InlineResponse20018 {
    data: Source;
    success: boolean;
}

export class InlineResponse20019 {
    data: Array<UnitCategory>;
    success: boolean;
}

export class InlineResponse20020 {
    data: UnitCategory;
    success: boolean;
}

export class InlineResponse20021 {
    data: Array<Unit>;
    success: boolean;
}

export class InlineResponse20022 {
    data: Unit;
    success: boolean;
}

export class InlineResponse20023 {
    data: Update;
    success: boolean;
}

export class InlineResponse20024 {
    data: Array<UserVariableRelationship>;
    success: boolean;
}

export class InlineResponse20025 {
    data: UserVariableRelationship;
    success: boolean;
}

export class InlineResponse20026 {
    data: UserVariable;
    success: boolean;
}

export class InlineResponse20027 {
    data: Array<VariableCategory>;
    success: boolean;
}

export class InlineResponse20028 {
    data: VariableCategory;
    success: boolean;
}

export class InlineResponse20029 {
    data: Array<VariableUserSource>;
    success: boolean;
}

export class InlineResponse20030 {
    data: VariableUserSource;
    success: boolean;
}

export class InlineResponse20031 {
    data: Array<Variable>;
    success: boolean;
}

export class InlineResponse20032 {
    data: Variable;
    success: boolean;
}

export class InlineResponse20033 {
    data: Array<Vote>;
    success: boolean;
}

export class InlineResponse20034 {
    data: Vote;
    success: boolean;
}


interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
}

class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export class VariableUserSourceApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all VariableUserSources
     * Get all VariableUserSources
     * @param accessToken User&#39;s OAuth2 access token
     * @param variableId ID of variable
     * @param userId ID of User
     * @param timestamp Time that this measurement occurred Uses epoch minute (epoch time divided by 60)
     * @param earliestMeasurementTime Earliest measurement time
     * @param latestMeasurementTime Latest measurement time
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public variableUserSourcesGet (accessToken?: string, variableId?: number, userId?: number, timestamp?: number, earliestMeasurementTime?: number, latestMeasurementTime?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_29;  }> {
        const path = this.basePath + '/variableUserSources';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (variableId !== undefined) {
            queryParameters['variable_id'] = variableId;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (timestamp !== undefined) {
            queryParameters['timestamp'] = timestamp;
        }

        if (earliestMeasurementTime !== undefined) {
            queryParameters['earliest_measurement_time'] = earliestMeasurementTime;
        }

        if (latestMeasurementTime !== undefined) {
            queryParameters['latest_measurement_time'] = latestMeasurementTime;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_29;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store VariableUserSource
     * Store VariableUserSource
     * @param accessToken User&#39;s OAuth2 access token
     * @param body VariableUserSource that should be stored
     */
    public variableUserSourcesPost (accessToken?: string, body?: VariableUserSource) : Promise<{ response: http.ClientResponse; body: inline_response_200_30;  }> {
        const path = this.basePath + '/variableUserSources';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_30;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get VariableUserSource
     * Get VariableUserSource
     * @param id id of VariableUserSource
     * @param sourceId source id of VariableUserSource
     * @param accessToken User&#39;s OAuth2 access token
     */
    public variableUserSourcesIdGet (id: number, sourceId: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_30;  }> {
        const path = this.basePath + '/variableUserSources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableUserSourcesIdGet');
        }

        // verify required parameter 'sourceId' is set
        if (!sourceId) {
            throw new Error('Missing required parameter sourceId when calling variableUserSourcesIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (sourceId !== undefined) {
            queryParameters['source_id'] = sourceId;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_30;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update VariableUserSource
     * Update VariableUserSource
     * @param id variable_id of VariableUserSource
     * @param sourceId source id of VariableUserSource
     * @param accessToken User&#39;s OAuth2 access token
     * @param body VariableUserSource that should be updated
     */
    public variableUserSourcesIdPut (id: number, sourceId: number, accessToken?: string, body?: VariableUserSource) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/variableUserSources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableUserSourcesIdPut');
        }

        // verify required parameter 'sourceId' is set
        if (!sourceId) {
            throw new Error('Missing required parameter sourceId when calling variableUserSourcesIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (sourceId !== undefined) {
            queryParameters['source_id'] = sourceId;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete VariableUserSource
     * Delete VariableUserSource
     * @param id variable_id of VariableUserSource
     * @param sourceId source id of VariableUserSource
     * @param accessToken User&#39;s OAuth2 access token
     */
    public variableUserSourcesIdDelete (id: number, sourceId: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/variableUserSources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableUserSourcesIdDelete');
        }

        // verify required parameter 'sourceId' is set
        if (!sourceId) {
            throw new Error('Missing required parameter sourceId when calling variableUserSourcesIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (sourceId !== undefined) {
            queryParameters['source_id'] = sourceId;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class MeasurementApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get measurements for this user
     * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
     * @param accessToken User&#39;s OAuth2 access token
     * @param userId ID of user that owns this measurement
     * @param clientId The ID of the client application which originally stored the measurement
     * @param connectorId The id for the connector data source from which the measurement was obtained
     * @param variableId ID of the variable for which we are creating the measurement records
     * @param sourceId Application or device used to record the measurement values
     * @param startTime start time for the measurement event. Use ISO 8601 datetime format
     * @param value The value of the measurement after conversion to the default unit for that variable
     * @param unitId The default unit id for the variable
     * @param originalValue Unconverted value of measurement as originally posted (before conversion to default unit)
     * @param originalUnitId Unit id of the measurement as originally submitted
     * @param duration Duration of the event being measurement in seconds
     * @param note An optional note the user may include with their measurement
     * @param latitude Latitude at which the measurement was taken
     * @param longitude Longitude at which the measurement was taken
     * @param location Optional human readable name for the location where the measurement was recorded
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param error An error message if there is a problem with the measurement
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public measurementsGet (accessToken?: string, userId?: number, clientId?: string, connectorId?: number, variableId?: number, sourceId?: number, startTime?: string, value?: number, unitId?: number, originalValue?: number, originalUnitId?: number, duration?: number, note?: string, latitude?: number, longitude?: number, location?: string, createdAt?: string, updatedAt?: string, error?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_13;  }> {
        const path = this.basePath + '/measurements';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (variableId !== undefined) {
            queryParameters['variable_id'] = variableId;
        }

        if (sourceId !== undefined) {
            queryParameters['source_id'] = sourceId;
        }

        if (startTime !== undefined) {
            queryParameters['start_time'] = startTime;
        }

        if (value !== undefined) {
            queryParameters['value'] = value;
        }

        if (unitId !== undefined) {
            queryParameters['unit_id'] = unitId;
        }

        if (originalValue !== undefined) {
            queryParameters['original_value'] = originalValue;
        }

        if (originalUnitId !== undefined) {
            queryParameters['original_unit_id'] = originalUnitId;
        }

        if (duration !== undefined) {
            queryParameters['duration'] = duration;
        }

        if (note !== undefined) {
            queryParameters['note'] = note;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (location !== undefined) {
            queryParameters['location'] = location;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (error !== undefined) {
            queryParameters['error'] = error;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_13;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Post a new set or update existing measurements to the database
     * You can submit or update multiple measurements in a measurements sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Measurement that should be stored
     */
    public measurementsPost (accessToken?: string, body?: MeasurementPost) : Promise<{ response: http.ClientResponse; body: inline_response_200_13;  }> {
        const path = this.basePath + '/measurements';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_13;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get Measurements CSV
     * Download a CSV containing all user measurements
     * @param accessToken User&#39;s OAuth2 access token
     */
    public measurementsCsvGet (accessToken?: string) : Promise<{ response: http.ClientResponse; body: any;  }> {
        const path = this.basePath + '/measurements/csv';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: any;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Post Request for Measurements CSV
     * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
     * @param accessToken User&#39;s OAuth2 access token
     */
    public measurementsRequestCsvPost (accessToken?: string) : Promise<{ response: http.ClientResponse; body: number;  }> {
        const path = this.basePath + '/measurements/request_csv';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: number;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get Measurement
     * Get Measurement
     * @param id id of Measurement
     * @param accessToken User&#39;s OAuth2 access token
     */
    public measurementsIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_14;  }> {
        const path = this.basePath + '/measurements/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling measurementsIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_14;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update Measurement
     * Update Measurement
     * @param id id of Measurement
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Measurement that should be updated
     */
    public measurementsIdPut (id: number, accessToken?: string, body?: Measurement) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/measurements/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling measurementsIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete Measurement
     * Delete Measurement
     * @param id id of Measurement
     * @param accessToken User&#39;s OAuth2 access token
     */
    public measurementsIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/measurements/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling measurementsIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class VariableApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all Variables
     * Get all Variables
     * @param accessToken User&#39;s OAuth2 access token
     * @param id id
     * @param clientId The ID of the client application which last created or updated this common variable
     * @param parentId ID of the parent variable if this variable has any parent
     * @param name User-defined variable display name
     * @param variableCategoryId Variable category ID
     * @param defaultUnitId ID of the default unit for the variable
     * @param combinationOperation How to combine values of this variable (for instance, to see a summary of the values over a month) SUM or MEAN
     * @param fillingValue Value for replacing null measurements
     * @param maximumAllowedValue Maximum reasonable value for this variable (uses default unit)
     * @param minimumAllowedValue Minimum reasonable value for this variable (uses default unit)
     * @param onsetDelay Estimated number of seconds that pass before a stimulus produces a perceivable effect
     * @param durationOfAction Estimated number of seconds following the onset delay in which a stimulus produces a perceivable effect
     * @param _public Is variable public
     * @param causeOnly A value of 1 indicates that this variable is generally a cause in a causal relationship.  An example of a causeOnly variable would be a variable such as Cloud Cover which would generally not be influenced by the behaviour of the user
     * @param mostCommonValue Most common value
     * @param mostCommonUnitId Most common Unit
     * @param standardDeviation Standard Deviation
     * @param variance Average variance for this variable based on all user data
     * @param mean Mean for this variable based on all user data
     * @param median Median for this variable based on all user data
     * @param numberOfMeasurements Number of measurements for this variable based on all user data
     * @param numberOfUniqueValues Number of unique values for this variable based on all user data
     * @param skewness Skewness for this variable based on all user data
     * @param kurtosis Kurtosis for this variable based on all user data
     * @param status status
     * @param errorMessage error_message
     * @param lastSuccessfulUpdateTime When this variable or its settings were last updated
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param productUrl Product URL
     * @param imageUrl Image URL
     * @param price Price
     * @param numberOfUserVariables Number of users who have data for this variable
     * @param outcome Outcome variables (those with `outcome` == 1) are variables for which a human would generally want to identify the influencing factors.  These include symptoms of illness, physique, mood, cognitive performance, etc.  Generally correlation calculations are only performed on outcome variables.
     * @param minimumRecordedValue Minimum recorded value of this variable based on all user data
     * @param maximumRecordedValue Maximum recorded value of this variable based on all user data
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort records by a given field name. If the field name is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public variablesGet (accessToken?: string, id?: number, clientId?: string, parentId?: number, name?: string, variableCategoryId?: number, defaultUnitId?: number, combinationOperation?: string, fillingValue?: number, maximumAllowedValue?: number, minimumAllowedValue?: number, onsetDelay?: number, durationOfAction?: number, _public?: number, causeOnly?: boolean, mostCommonValue?: number, mostCommonUnitId?: number, standardDeviation?: number, variance?: number, mean?: number, median?: number, numberOfMeasurements?: number, numberOfUniqueValues?: number, skewness?: number, kurtosis?: number, status?: string, errorMessage?: string, lastSuccessfulUpdateTime?: string, createdAt?: string, updatedAt?: string, productUrl?: string, imageUrl?: string, price?: number, numberOfUserVariables?: number, outcome?: boolean, minimumRecordedValue?: number, maximumRecordedValue?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_31;  }> {
        const path = this.basePath + '/variables';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (parentId !== undefined) {
            queryParameters['parent_id'] = parentId;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (variableCategoryId !== undefined) {
            queryParameters['variable_category_id'] = variableCategoryId;
        }

        if (defaultUnitId !== undefined) {
            queryParameters['default_unit_id'] = defaultUnitId;
        }

        if (combinationOperation !== undefined) {
            queryParameters['combination_operation'] = combinationOperation;
        }

        if (fillingValue !== undefined) {
            queryParameters['filling_value'] = fillingValue;
        }

        if (maximumAllowedValue !== undefined) {
            queryParameters['maximum_allowed_value'] = maximumAllowedValue;
        }

        if (minimumAllowedValue !== undefined) {
            queryParameters['minimum_allowed_value'] = minimumAllowedValue;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (_public !== undefined) {
            queryParameters['public'] = _public;
        }

        if (causeOnly !== undefined) {
            queryParameters['cause_only'] = causeOnly;
        }

        if (mostCommonValue !== undefined) {
            queryParameters['most_common_value'] = mostCommonValue;
        }

        if (mostCommonUnitId !== undefined) {
            queryParameters['most_common_unit_id'] = mostCommonUnitId;
        }

        if (standardDeviation !== undefined) {
            queryParameters['standard_deviation'] = standardDeviation;
        }

        if (variance !== undefined) {
            queryParameters['variance'] = variance;
        }

        if (mean !== undefined) {
            queryParameters['mean'] = mean;
        }

        if (median !== undefined) {
            queryParameters['median'] = median;
        }

        if (numberOfMeasurements !== undefined) {
            queryParameters['number_of_measurements'] = numberOfMeasurements;
        }

        if (numberOfUniqueValues !== undefined) {
            queryParameters['number_of_unique_values'] = numberOfUniqueValues;
        }

        if (skewness !== undefined) {
            queryParameters['skewness'] = skewness;
        }

        if (kurtosis !== undefined) {
            queryParameters['kurtosis'] = kurtosis;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (errorMessage !== undefined) {
            queryParameters['error_message'] = errorMessage;
        }

        if (lastSuccessfulUpdateTime !== undefined) {
            queryParameters['last_successful_update_time'] = lastSuccessfulUpdateTime;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (productUrl !== undefined) {
            queryParameters['product_url'] = productUrl;
        }

        if (imageUrl !== undefined) {
            queryParameters['image_url'] = imageUrl;
        }

        if (price !== undefined) {
            queryParameters['price'] = price;
        }

        if (numberOfUserVariables !== undefined) {
            queryParameters['number_of_user_variables'] = numberOfUserVariables;
        }

        if (outcome !== undefined) {
            queryParameters['outcome'] = outcome;
        }

        if (minimumRecordedValue !== undefined) {
            queryParameters['minimum_recorded_value'] = minimumRecordedValue;
        }

        if (maximumRecordedValue !== undefined) {
            queryParameters['maximum_recorded_value'] = maximumRecordedValue;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_31;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store Variable
     * Allows the client to create a new variable in the `variables` table.
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Variable that should be stored
     */
    public variablesPost (accessToken?: string, body?: Variable) : Promise<{ response: http.ClientResponse; body: inline_response_200_32;  }> {
        const path = this.basePath + '/variables';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_32;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get Variable
     * Get Variable
     * @param id id of Variable
     * @param accessToken User&#39;s OAuth2 access token
     */
    public variablesIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_32;  }> {
        const path = this.basePath + '/variables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variablesIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_32;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update Variable
     * Update Variable
     * @param id id of Variable
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Variable that should be updated
     */
    public variablesIdPut (id: number, accessToken?: string, body?: Variable) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/variables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variablesIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete Variable
     * Delete Variable
     * @param id id of Variable
     * @param accessToken User&#39;s OAuth2 access token
     */
    public variablesIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/variables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variablesIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class UpdateApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all Updates
     * Get all Updates
     * @param accessToken User&#39;s OAuth2 access token
     * @param userId user_id
     * @param connectorId connector_id
     * @param numberOfMeasurements number_of_measurements
     * @param success success
     * @param message message
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public updatesGet (accessToken?: string, userId?: number, connectorId?: number, numberOfMeasurements?: number, success?: boolean, message?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_15;  }> {
        const path = this.basePath + '/updates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (numberOfMeasurements !== undefined) {
            queryParameters['number_of_measurements'] = numberOfMeasurements;
        }

        if (success !== undefined) {
            queryParameters['success'] = success;
        }

        if (message !== undefined) {
            queryParameters['message'] = message;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_15;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store Update
     * Store Update
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Update that should be stored
     */
    public updatesPost (accessToken?: string, body?: Update) : Promise<{ response: http.ClientResponse; body: inline_response_200_23;  }> {
        const path = this.basePath + '/updates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_23;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get Update
     * Get Update
     * @param id id of Update
     * @param accessToken User&#39;s OAuth2 access token
     */
    public updatesIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_23;  }> {
        const path = this.basePath + '/updates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling updatesIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_23;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update Update
     * Update Update
     * @param id id of Update
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Update that should be updated
     */
    public updatesIdPut (id: number, accessToken?: string, body?: Update) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/updates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling updatesIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete Update
     * Delete Update
     * @param id id of Update
     * @param accessToken User&#39;s OAuth2 access token
     */
    public updatesIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/updates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling updatesIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class AggregatedCorrelationApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all AggregatedCorrelations
     * Get all AggregatedCorrelations
     * @param accessToken User&#39;s OAuth2 access token
     * @param correlation Pearson correlation coefficient between cause and effect measurements
     * @param causeId Variable ID of the predictor variable for which the user desires correlations
     * @param effectId Variable ID of the outcome variable for which the user desires correlations
     * @param onsetDelay User estimated (or default number of seconds) after cause measurement before a perceivable effect is observed
     * @param durationOfAction Number of seconds over which the predictor variable event is expected to produce a perceivable effect following the onset delay
     * @param numberOfPairs Number of predictor/outcome data points used in the analysis
     * @param valuePredictingHighOutcome Predictor daily aggregated measurement value that predicts an above average effect measurement value (in default unit for predictor variable)
     * @param valuePredictingLowOutcome Predictor daily aggregated measurement value that predicts a below average effect measurement value (in default unit for outcome variable)
     * @param optimalPearsonProduct Optimal Pearson Product
     * @param numberOfUsers Number of users whose data was used in this aggregation
     * @param numberOfCorrelations Number of correlational analyses used in this aggregation
     * @param statisticalSignificance A function of the effect size and sample size
     * @param causeUnit Abbreviated unit name for the predictor variable
     * @param causeUnitId Unit ID for the predictor variable
     * @param causeChanges Number of times that the predictor time series changes
     * @param effectChanges Number of times that the predictor time series changes
     * @param aggregateQmScore Aggregated QM Score which is directly proportional with the relevance of each predictor or outcome
     * @param createdAt Date at which the analysis was first performed
     * @param updatedAt Date at which the analysis was last updated
     * @param status Indicates whether an analysis is up to date (UPDATED), needs to be updated (WAITING), or had an error (ERROR)
     * @param errorMessage Message describing any problems encountered during the analysis
     * @param lastSuccessfulUpdateTime Last Successful update time
     * @param reversePearsonCorrelationCoefficient Correlation when cause and effect are reversed. For any causal relationship, the forward correlation should exceed the reverse correlation
     * @param predictivePearsonCorrelationCoefficient Predictive Pearson Correlation Coefficient
     * @param limit Limit the number of results returned
     * @param offset Records from give Offset
     * @param sort Sort records by given field
     */
    public aggregatedCorrelationsGet (accessToken?: string, correlation?: number, causeId?: number, effectId?: number, onsetDelay?: number, durationOfAction?: number, numberOfPairs?: number, valuePredictingHighOutcome?: number, valuePredictingLowOutcome?: number, optimalPearsonProduct?: number, numberOfUsers?: number, numberOfCorrelations?: number, statisticalSignificance?: number, causeUnit?: string, causeUnitId?: number, causeChanges?: number, effectChanges?: number, aggregateQmScore?: number, createdAt?: string, updatedAt?: string, status?: string, errorMessage?: string, lastSuccessfulUpdateTime?: string, reversePearsonCorrelationCoefficient?: number, predictivePearsonCorrelationCoefficient?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200;  }> {
        const path = this.basePath + '/aggregatedCorrelations';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (correlation !== undefined) {
            queryParameters['correlation'] = correlation;
        }

        if (causeId !== undefined) {
            queryParameters['cause_id'] = causeId;
        }

        if (effectId !== undefined) {
            queryParameters['effect_id'] = effectId;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (numberOfPairs !== undefined) {
            queryParameters['number_of_pairs'] = numberOfPairs;
        }

        if (valuePredictingHighOutcome !== undefined) {
            queryParameters['value_predicting_high_outcome'] = valuePredictingHighOutcome;
        }

        if (valuePredictingLowOutcome !== undefined) {
            queryParameters['value_predicting_low_outcome'] = valuePredictingLowOutcome;
        }

        if (optimalPearsonProduct !== undefined) {
            queryParameters['optimal_pearson_product'] = optimalPearsonProduct;
        }

        if (numberOfUsers !== undefined) {
            queryParameters['number_of_users'] = numberOfUsers;
        }

        if (numberOfCorrelations !== undefined) {
            queryParameters['number_of_correlations'] = numberOfCorrelations;
        }

        if (statisticalSignificance !== undefined) {
            queryParameters['statistical_significance'] = statisticalSignificance;
        }

        if (causeUnit !== undefined) {
            queryParameters['cause_unit'] = causeUnit;
        }

        if (causeUnitId !== undefined) {
            queryParameters['cause_unit_id'] = causeUnitId;
        }

        if (causeChanges !== undefined) {
            queryParameters['cause_changes'] = causeChanges;
        }

        if (effectChanges !== undefined) {
            queryParameters['effect_changes'] = effectChanges;
        }

        if (aggregateQmScore !== undefined) {
            queryParameters['aggregate_qm_score'] = aggregateQmScore;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (errorMessage !== undefined) {
            queryParameters['error_message'] = errorMessage;
        }

        if (lastSuccessfulUpdateTime !== undefined) {
            queryParameters['last_successful_update_time'] = lastSuccessfulUpdateTime;
        }

        if (reversePearsonCorrelationCoefficient !== undefined) {
            queryParameters['reverse_pearson_correlation_coefficient'] = reversePearsonCorrelationCoefficient;
        }

        if (predictivePearsonCorrelationCoefficient !== undefined) {
            queryParameters['predictive_pearson_correlation_coefficient'] = predictivePearsonCorrelationCoefficient;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store AggregatedCorrelation
     * Store AggregatedCorrelation
     * @param accessToken User&#39;s OAuth2 access token
     * @param body AggregatedCorrelation that should be stored
     */
    public aggregatedCorrelationsPost (accessToken?: string, body?: AggregatedCorrelation) : Promise<{ response: http.ClientResponse; body: inline_response_200_1;  }> {
        const path = this.basePath + '/aggregatedCorrelations';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_1;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get AggregatedCorrelation
     * Get AggregatedCorrelation
     * @param id id of AggregatedCorrelation
     * @param accessToken User&#39;s OAuth2 access token
     */
    public aggregatedCorrelationsIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_1;  }> {
        const path = this.basePath + '/aggregatedCorrelations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling aggregatedCorrelationsIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_1;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update AggregatedCorrelation
     * Update AggregatedCorrelation
     * @param id id of AggregatedCorrelation
     * @param accessToken User&#39;s OAuth2 access token
     * @param body AggregatedCorrelation that should be updated
     */
    public aggregatedCorrelationsIdPut (id: number, accessToken?: string, body?: AggregatedCorrelation) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/aggregatedCorrelations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling aggregatedCorrelationsIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete AggregatedCorrelation
     * Delete AggregatedCorrelation
     * @param id id of AggregatedCorrelation
     * @param accessToken User&#39;s OAuth2 access token
     */
    public aggregatedCorrelationsIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/aggregatedCorrelations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling aggregatedCorrelationsIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class ConnectorApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get list of Connectors
     * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
     * @param accessToken User&#39;s OAuth2 access token
     * @param name Lowercase system name for the data source
     * @param displayName Pretty display name for the data source
     * @param image URL to the image of the connector logo
     * @param getItUrl URL to a site where one can get this device or application
     * @param shortDescription Short description of the service (such as the categories it tracks)
     * @param longDescription Longer paragraph description of the data provider
     * @param enabled Set to 1 if the connector should be returned when listing connectors
     * @param oauth Set to 1 if the connector uses OAuth authentication as opposed to username/password
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public connectorsGet (accessToken?: string, name?: string, displayName?: string, image?: string, getItUrl?: string, shortDescription?: string, longDescription?: string, enabled?: boolean, oauth?: boolean, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_7;  }> {
        const path = this.basePath + '/connectors';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (displayName !== undefined) {
            queryParameters['display_name'] = displayName;
        }

        if (image !== undefined) {
            queryParameters['image'] = image;
        }

        if (getItUrl !== undefined) {
            queryParameters['get_it_url'] = getItUrl;
        }

        if (shortDescription !== undefined) {
            queryParameters['short_description'] = shortDescription;
        }

        if (longDescription !== undefined) {
            queryParameters['long_description'] = longDescription;
        }

        if (enabled !== undefined) {
            queryParameters['enabled'] = enabled;
        }

        if (oauth !== undefined) {
            queryParameters['oauth'] = oauth;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_7;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store Connector
     * Store Connector
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Connector that should be stored
     */
    public connectorsPost (accessToken?: string, body?: Connector) : Promise<{ response: http.ClientResponse; body: inline_response_200_8;  }> {
        const path = this.basePath + '/connectors';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_8;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get connector info for user
     * Returns information about the connector such as the connector id, whether or not is connected for this user (i.e. we have a token or credentials), and its update history for the user.
     * @param id id of Connector
     * @param accessToken User&#39;s OAuth2 access token
     */
    public connectorsIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_8;  }> {
        const path = this.basePath + '/connectors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectorsIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_8;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update Connector
     * Update Connector
     * @param id id of Connector
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Connector that should be updated
     */
    public connectorsIdPut (id: number, accessToken?: string, body?: Connector) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/connectors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectorsIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete Connector
     * Delete Connector
     * @param id id of Connector
     * @param accessToken User&#39;s OAuth2 access token
     */
    public connectorsIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/connectors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectorsIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class OrganizationApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all Connections
     * Get all Connections
     * @param accessToken Organization&#39;s OAuth2 access token
     * @param connectorId The id for the connector data source for which the connection is connected
     * @param connectStatus Indicates whether a connector is currently connected to a service for a user.
     * @param connectError Error message if there is a problem with authorizing this connection.
     * @param updateRequestedAt Time at which an update was requested by a user.
     * @param updateStatus Indicates whether a connector is currently updated.
     * @param updateError Indicates if there was an error during the update.
     * @param lastSuccessfulUpdatedAt The time at which the connector was last successfully updated.
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public organizationConnectionsGet (accessToken?: string, connectorId?: number, connectStatus?: string, connectError?: string, updateRequestedAt?: string, updateStatus?: string, updateError?: string, lastSuccessfulUpdatedAt?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_5;  }> {
        const path = this.basePath + '/organization/connections';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (connectStatus !== undefined) {
            queryParameters['connect_status'] = connectStatus;
        }

        if (connectError !== undefined) {
            queryParameters['connect_error'] = connectError;
        }

        if (updateRequestedAt !== undefined) {
            queryParameters['update_requested_at'] = updateRequestedAt;
        }

        if (updateStatus !== undefined) {
            queryParameters['update_status'] = updateStatus;
        }

        if (updateError !== undefined) {
            queryParameters['update_error'] = updateError;
        }

        if (lastSuccessfulUpdatedAt !== undefined) {
            queryParameters['last_successful_updated_at'] = lastSuccessfulUpdatedAt;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_5;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get all Credentials
     * Get all Credentials
     * @param accessToken Organization&#39;s OAuth2 access token
     * @param connectorId The id for the connector data source from which the credential was obtained
     * @param attrKey Attribute name such as token, userid, username, or password
     * @param attrValue Encrypted value for the attribute specified
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public organizationCredentialsGet (accessToken?: string, connectorId?: number, attrKey?: string, attrValue?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_11;  }> {
        const path = this.basePath + '/organization/credentials';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (attrKey !== undefined) {
            queryParameters['attr_key'] = attrKey;
        }

        if (attrValue !== undefined) {
            queryParameters['attr_value'] = attrValue;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_11;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get measurements for all users using your application
     * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
     * @param accessToken Organization&#39;s OAuth2 access token
     * @param clientId The ID of the client application which originally stored the measurement
     * @param connectorId The id for the connector data source from which the measurement was obtained
     * @param variableId ID of the variable for which we are creating the measurement records
     * @param sourceId Application or device used to record the measurement values
     * @param startTime start time for the measurement event. Use ISO 8601 datetime format
     * @param value The value of the measurement after conversion to the default unit for that variable
     * @param unitId The default unit id for the variable
     * @param originalValue Unconverted value of measurement as originally posted (before conversion to default unit)
     * @param originalUnitId Unit id of the measurement as originally submitted
     * @param duration Duration of the event being measurement in seconds
     * @param note An optional note the user may include with their measurement
     * @param latitude Latitude at which the measurement was taken
     * @param longitude Longitude at which the measurement was taken
     * @param location Optional human readable name for the location where the measurement was recorded
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param error An error message if there is a problem with the measurement
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public organizationMeasurementsGet (accessToken?: string, clientId?: string, connectorId?: number, variableId?: number, sourceId?: number, startTime?: string, value?: number, unitId?: number, originalValue?: number, originalUnitId?: number, duration?: number, note?: string, latitude?: number, longitude?: number, location?: string, createdAt?: string, updatedAt?: string, error?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_13;  }> {
        const path = this.basePath + '/organization/measurements';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (variableId !== undefined) {
            queryParameters['variable_id'] = variableId;
        }

        if (sourceId !== undefined) {
            queryParameters['source_id'] = sourceId;
        }

        if (startTime !== undefined) {
            queryParameters['start_time'] = startTime;
        }

        if (value !== undefined) {
            queryParameters['value'] = value;
        }

        if (unitId !== undefined) {
            queryParameters['unit_id'] = unitId;
        }

        if (originalValue !== undefined) {
            queryParameters['original_value'] = originalValue;
        }

        if (originalUnitId !== undefined) {
            queryParameters['original_unit_id'] = originalUnitId;
        }

        if (duration !== undefined) {
            queryParameters['duration'] = duration;
        }

        if (note !== undefined) {
            queryParameters['note'] = note;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (location !== undefined) {
            queryParameters['location'] = location;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (error !== undefined) {
            queryParameters['error'] = error;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_13;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get all Updates
     * Get all Updates
     * @param accessToken Organization&#39;s OAuth2 access token
     * @param connectorId connector_id
     * @param numberOfMeasurements number_of_measurements
     * @param success success
     * @param message message
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public organizationUpdatesGet (accessToken?: string, connectorId?: number, numberOfMeasurements?: number, success?: boolean, message?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_15;  }> {
        const path = this.basePath + '/organization/updates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (numberOfMeasurements !== undefined) {
            queryParameters['number_of_measurements'] = numberOfMeasurements;
        }

        if (success !== undefined) {
            queryParameters['success'] = success;
        }

        if (message !== undefined) {
            queryParameters['message'] = message;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_15;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get all UserVariables
     * Get all UserVariables
     * @param accessToken User&#39;s OAuth2 access token
     * @param clientId The ID of the client application which last created or updated this user variable
     * @param parentId ID of the parent variable if this variable has any parent
     * @param variableId ID of variable
     * @param defaultUnitId D of unit to use for this variable
     * @param minimumAllowedValue Minimum reasonable value for this variable (uses default unit)
     * @param maximumAllowedValue Maximum reasonable value for this variable (uses default unit)
     * @param fillingValue Value for replacing null measurements
     * @param joinWith The Variable this Variable should be joined with. If the variable is joined with some other variable then it is not shown to user in the list of variables
     * @param onsetDelay Estimated number of seconds that pass before a stimulus produces a perceivable effect
     * @param durationOfAction Estimated duration of time following the onset delay in which a stimulus produces a perceivable effect
     * @param variableCategoryId ID of variable category
     * @param updated updated
     * @param _public Is variable public
     * @param causeOnly A value of 1 indicates that this variable is generally a cause in a causal relationship.  An example of a causeOnly variable would be a variable such as Cloud Cover which would generally not be influenced by the behaviour of the user
     * @param fillingType 0 -&gt; No filling, 1 -&gt; Use filling-value
     * @param numberOfMeasurements Number of measurements
     * @param numberOfProcessedMeasurements Number of processed measurements
     * @param measurementsAtLastAnalysis Number of measurements at last analysis
     * @param lastUnitId ID of last Unit
     * @param lastOriginalUnitId ID of last original Unit
     * @param lastOriginalValue Last original value which is stored
     * @param lastValue Last Value
     * @param lastOriginalValue2 Last original value which is stored
     * @param lastSourceId ID of last source
     * @param numberOfCorrelations Number of correlations for this variable
     * @param status status
     * @param errorMessage error_message
     * @param lastSuccessfulUpdateTime When this variable or its settings were last updated
     * @param standardDeviation Standard deviation
     * @param variance Variance
     * @param minimumRecordedValue Minimum recorded value of this variable
     * @param maximumRecordedValue Maximum recorded value of this variable
     * @param mean Mean
     * @param median Median
     * @param mostCommonUnitId Most common Unit ID
     * @param mostCommonValue Most common value
     * @param numberOfUniqueDailyValues Number of unique daily values
     * @param numberOfChanges Number of changes
     * @param skewness Skewness
     * @param kurtosis Kurtosis
     * @param latitude Latitude
     * @param longitude Longitude
     * @param location Location
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param outcome Outcome variables (those with `outcome` == 1) are variables for which a human would generally want to identify the influencing factors.  These include symptoms of illness, physique, mood, cognitive performance, etc.  Generally correlation calculations are only performed on outcome variables
     * @param sources Comma-separated list of source names to limit variables to those sources
     * @param earliestSourceTime Earliest source time
     * @param latestSourceTime Latest source time
     * @param earliestMeasurementTime Earliest measurement time
     * @param latestMeasurementTime Latest measurement time
     * @param earliestFillingTime Earliest filling time
     * @param latestFillingTime Latest filling time
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public organizationUserVariablesGet (accessToken?: string, clientId?: string, parentId?: number, variableId?: number, defaultUnitId?: number, minimumAllowedValue?: number, maximumAllowedValue?: number, fillingValue?: number, joinWith?: number, onsetDelay?: number, durationOfAction?: number, variableCategoryId?: number, updated?: number, _public?: number, causeOnly?: boolean, fillingType?: string, numberOfMeasurements?: number, numberOfProcessedMeasurements?: number, measurementsAtLastAnalysis?: number, lastUnitId?: number, lastOriginalUnitId?: number, lastOriginalValue?: number, lastValue?: number, lastOriginalValue2?: number, lastSourceId?: number, numberOfCorrelations?: number, status?: string, errorMessage?: string, lastSuccessfulUpdateTime?: string, standardDeviation?: number, variance?: number, minimumRecordedValue?: number, maximumRecordedValue?: number, mean?: number, median?: number, mostCommonUnitId?: number, mostCommonValue?: number, numberOfUniqueDailyValues?: number, numberOfChanges?: number, skewness?: number, kurtosis?: number, latitude?: number, longitude?: number, location?: string, createdAt?: string, updatedAt?: string, outcome?: boolean, sources?: string, earliestSourceTime?: number, latestSourceTime?: number, earliestMeasurementTime?: number, latestMeasurementTime?: number, earliestFillingTime?: number, latestFillingTime?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_16;  }> {
        const path = this.basePath + '/organization/userVariables';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (parentId !== undefined) {
            queryParameters['parent_id'] = parentId;
        }

        if (variableId !== undefined) {
            queryParameters['variable_id'] = variableId;
        }

        if (defaultUnitId !== undefined) {
            queryParameters['default_unit_id'] = defaultUnitId;
        }

        if (minimumAllowedValue !== undefined) {
            queryParameters['minimum_allowed_value'] = minimumAllowedValue;
        }

        if (maximumAllowedValue !== undefined) {
            queryParameters['maximum_allowed_value'] = maximumAllowedValue;
        }

        if (fillingValue !== undefined) {
            queryParameters['filling_value'] = fillingValue;
        }

        if (joinWith !== undefined) {
            queryParameters['join_with'] = joinWith;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (variableCategoryId !== undefined) {
            queryParameters['variable_category_id'] = variableCategoryId;
        }

        if (updated !== undefined) {
            queryParameters['updated'] = updated;
        }

        if (_public !== undefined) {
            queryParameters['public'] = _public;
        }

        if (causeOnly !== undefined) {
            queryParameters['cause_only'] = causeOnly;
        }

        if (fillingType !== undefined) {
            queryParameters['filling_type'] = fillingType;
        }

        if (numberOfMeasurements !== undefined) {
            queryParameters['number_of_measurements'] = numberOfMeasurements;
        }

        if (numberOfProcessedMeasurements !== undefined) {
            queryParameters['number_of_processed_measurements'] = numberOfProcessedMeasurements;
        }

        if (measurementsAtLastAnalysis !== undefined) {
            queryParameters['measurements_at_last_analysis'] = measurementsAtLastAnalysis;
        }

        if (lastUnitId !== undefined) {
            queryParameters['last_unit_id'] = lastUnitId;
        }

        if (lastOriginalUnitId !== undefined) {
            queryParameters['last_original_unit_id'] = lastOriginalUnitId;
        }

        if (lastOriginalValue !== undefined) {
            queryParameters['last_original_value'] = lastOriginalValue;
        }

        if (lastValue !== undefined) {
            queryParameters['last_value'] = lastValue;
        }

        if (lastOriginalValue2 !== undefined) {
            queryParameters['last_original_value'] = lastOriginalValue2;
        }

        if (lastSourceId !== undefined) {
            queryParameters['last_source_id'] = lastSourceId;
        }

        if (numberOfCorrelations !== undefined) {
            queryParameters['number_of_correlations'] = numberOfCorrelations;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (errorMessage !== undefined) {
            queryParameters['error_message'] = errorMessage;
        }

        if (lastSuccessfulUpdateTime !== undefined) {
            queryParameters['last_successful_update_time'] = lastSuccessfulUpdateTime;
        }

        if (standardDeviation !== undefined) {
            queryParameters['standard_deviation'] = standardDeviation;
        }

        if (variance !== undefined) {
            queryParameters['variance'] = variance;
        }

        if (minimumRecordedValue !== undefined) {
            queryParameters['minimum_recorded_value'] = minimumRecordedValue;
        }

        if (maximumRecordedValue !== undefined) {
            queryParameters['maximum_recorded_value'] = maximumRecordedValue;
        }

        if (mean !== undefined) {
            queryParameters['mean'] = mean;
        }

        if (median !== undefined) {
            queryParameters['median'] = median;
        }

        if (mostCommonUnitId !== undefined) {
            queryParameters['most_common_unit_id'] = mostCommonUnitId;
        }

        if (mostCommonValue !== undefined) {
            queryParameters['most_common_value'] = mostCommonValue;
        }

        if (numberOfUniqueDailyValues !== undefined) {
            queryParameters['number_of_unique_daily_values'] = numberOfUniqueDailyValues;
        }

        if (numberOfChanges !== undefined) {
            queryParameters['number_of_changes'] = numberOfChanges;
        }

        if (skewness !== undefined) {
            queryParameters['skewness'] = skewness;
        }

        if (kurtosis !== undefined) {
            queryParameters['kurtosis'] = kurtosis;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (location !== undefined) {
            queryParameters['location'] = location;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (outcome !== undefined) {
            queryParameters['outcome'] = outcome;
        }

        if (sources !== undefined) {
            queryParameters['sources'] = sources;
        }

        if (earliestSourceTime !== undefined) {
            queryParameters['earliest_source_time'] = earliestSourceTime;
        }

        if (latestSourceTime !== undefined) {
            queryParameters['latest_source_time'] = latestSourceTime;
        }

        if (earliestMeasurementTime !== undefined) {
            queryParameters['earliest_measurement_time'] = earliestMeasurementTime;
        }

        if (latestMeasurementTime !== undefined) {
            queryParameters['latest_measurement_time'] = latestMeasurementTime;
        }

        if (earliestFillingTime !== undefined) {
            queryParameters['earliest_filling_time'] = earliestFillingTime;
        }

        if (latestFillingTime !== undefined) {
            queryParameters['latest_filling_time'] = latestFillingTime;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_16;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class CommonVariableRelationshipApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all CommonVariableRelationships
     * Get all CommonVariableRelationships
     * @param accessToken User&#39;s OAuth2 access token
     * @param id id
     * @param confidenceLevel Our confidence that a consistent predictive relationship exists based on the amount of evidence, reproducibility, and other factors
     * @param confidenceScore A quantitative representation of our confidence that a consistent predictive relationship exists based on the amount of evidence, reproducibility, and other factors
     * @param direction Direction is positive if higher predictor values generally precede higher outcome values. Direction is negative if higher predictor values generally precede lower outcome values.
     * @param durationOfAction Estimated number of seconds following the onset delay in which a stimulus produces a perceivable effect
     * @param errorMessage error_message
     * @param onsetDelay Estimated number of seconds that pass before a stimulus produces a perceivable effect
     * @param outcomeVariableId Variable ID for the outcome variable
     * @param predictorVariableId Variable ID for the predictor variable
     * @param predictorUnitId ID for default unit of the predictor variable
     * @param sinnRank A value representative of the relevance of this predictor relative to other predictors of this outcome.  Usually used for relevancy sorting.
     * @param strengthScore A value represented to the size of the effect which the predictor appears to have on the outcome.
     * @param strengthLevel Can be weak, medium, or strong based on the size of the effect which the predictor appears to have on the outcome relative to other variable relationship strength scores.
     * @param upVotes Number of users who feel that there is a plausible causal relationship between the predictor and outcome variables.
     * @param downVotes Number of users who do not feel that there is a plausible causal relationship between the predictor and outcome variables.
     * @param valuePredictingHighOutcome Value for the predictor variable (in it&#39;s default unit) which typically precedes an above average outcome value
     * @param valuePredictingLowOutcome Value for the predictor variable (in it&#39;s default unit) which typically precedes a below average outcome value
     * @param numberOfUsers Number of users whose data was aggregated to obtain this relationship
     * @param dataSource data_source
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public commonVariableRelationshipsGet (accessToken?: string, id?: number, confidenceLevel?: string, confidenceScore?: number, direction?: string, durationOfAction?: number, errorMessage?: string, onsetDelay?: number, outcomeVariableId?: number, predictorVariableId?: number, predictorUnitId?: number, sinnRank?: number, strengthScore?: number, strengthLevel?: string, upVotes?: number, downVotes?: number, valuePredictingHighOutcome?: number, valuePredictingLowOutcome?: number, numberOfUsers?: number, dataSource?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_3;  }> {
        const path = this.basePath + '/commonVariableRelationships';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        if (confidenceLevel !== undefined) {
            queryParameters['confidence_level'] = confidenceLevel;
        }

        if (confidenceScore !== undefined) {
            queryParameters['confidence_score'] = confidenceScore;
        }

        if (direction !== undefined) {
            queryParameters['direction'] = direction;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (errorMessage !== undefined) {
            queryParameters['error_message'] = errorMessage;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (outcomeVariableId !== undefined) {
            queryParameters['outcome_variable_id'] = outcomeVariableId;
        }

        if (predictorVariableId !== undefined) {
            queryParameters['predictor_variable_id'] = predictorVariableId;
        }

        if (predictorUnitId !== undefined) {
            queryParameters['predictor_unit_id'] = predictorUnitId;
        }

        if (sinnRank !== undefined) {
            queryParameters['sinn_rank'] = sinnRank;
        }

        if (strengthScore !== undefined) {
            queryParameters['strength_score'] = strengthScore;
        }

        if (strengthLevel !== undefined) {
            queryParameters['strength_level'] = strengthLevel;
        }

        if (upVotes !== undefined) {
            queryParameters['up_votes'] = upVotes;
        }

        if (downVotes !== undefined) {
            queryParameters['down_votes'] = downVotes;
        }

        if (valuePredictingHighOutcome !== undefined) {
            queryParameters['value_predicting_high_outcome'] = valuePredictingHighOutcome;
        }

        if (valuePredictingLowOutcome !== undefined) {
            queryParameters['value_predicting_low_outcome'] = valuePredictingLowOutcome;
        }

        if (numberOfUsers !== undefined) {
            queryParameters['number_of_users'] = numberOfUsers;
        }

        if (dataSource !== undefined) {
            queryParameters['data_source'] = dataSource;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_3;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store CommonVariableRelationship
     * Store CommonVariableRelationship
     * @param accessToken User&#39;s OAuth2 access token
     * @param body CommonVariableRelationship that should be stored
     */
    public commonVariableRelationshipsPost (accessToken?: string, body?: CommonVariableRelationship) : Promise<{ response: http.ClientResponse; body: inline_response_200_4;  }> {
        const path = this.basePath + '/commonVariableRelationships';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_4;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get CommonVariableRelationship
     * Get CommonVariableRelationship
     * @param id id of CommonVariableRelationship
     * @param accessToken User&#39;s OAuth2 access token
     */
    public commonVariableRelationshipsIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_4;  }> {
        const path = this.basePath + '/commonVariableRelationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling commonVariableRelationshipsIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_4;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update CommonVariableRelationship
     * Update CommonVariableRelationship
     * @param id id of CommonVariableRelationship
     * @param accessToken User&#39;s OAuth2 access token
     * @param body CommonVariableRelationship that should be updated
     */
    public commonVariableRelationshipsIdPut (id: number, accessToken?: string, body?: CommonVariableRelationship) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/commonVariableRelationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling commonVariableRelationshipsIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete CommonVariableRelationship
     * Delete CommonVariableRelationship
     * @param id id of CommonVariableRelationship
     * @param accessToken User&#39;s OAuth2 access token
     */
    public commonVariableRelationshipsIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/commonVariableRelationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling commonVariableRelationshipsIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class CorrelationApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all Correlations
     * Get all Correlations
     * @param accessToken User&#39;s OAuth2 access token
     * @param timestamp Time at which correlation was calculated
     * @param userId ID of user that owns this correlation
     * @param correlation Pearson correlation coefficient between cause and effect measurements
     * @param causeId variable ID of the predictor variable for which the user desires correlations
     * @param effectId variable ID of the outcome variable for which the user desires correlations
     * @param onsetDelay User estimated or default time after cause measurement before a perceivable effect is observed
     * @param durationOfAction Time over which the cause is expected to produce a perceivable effect following the onset delay
     * @param numberOfPairs Number of points that went into the correlation calculation
     * @param valuePredictingHighOutcome cause value that predicts an above average effect value (in default unit for predictor variable)
     * @param valuePredictingLowOutcome cause value that predicts a below average effect value (in default unit for predictor variable)
     * @param optimalPearsonProduct Optimal Pearson Product
     * @param vote Vote
     * @param statisticalSignificance A function of the effect size and sample size
     * @param causeUnit Unit of the predictor variable
     * @param causeUnitId Unit ID of the predictor variable
     * @param causeChanges Cause changes
     * @param effectChanges Effect changes
     * @param qmScore QM Score
     * @param error error
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record in the database was last updated. Use ISO 8601 datetime format
     * @param reversePearsonCorrelationCoefficient Correlation when cause and effect are reversed. For any causal relationship, the forward correlation should exceed the reverse correlation
     * @param predictivePearsonCorrelationCoefficient Predictive Pearson Correlation Coefficient
     * @param limit Limit the number of results returned
     * @param offset Records from give Offset
     * @param sort Sort records by given field
     */
    public correlationsGet (accessToken?: string, timestamp?: number, userId?: number, correlation?: number, causeId?: number, effectId?: number, onsetDelay?: number, durationOfAction?: number, numberOfPairs?: number, valuePredictingHighOutcome?: number, valuePredictingLowOutcome?: number, optimalPearsonProduct?: number, vote?: number, statisticalSignificance?: number, causeUnit?: string, causeUnitId?: number, causeChanges?: number, effectChanges?: number, qmScore?: number, error?: string, createdAt?: string, updatedAt?: string, reversePearsonCorrelationCoefficient?: number, predictivePearsonCorrelationCoefficient?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_9;  }> {
        const path = this.basePath + '/correlations';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (timestamp !== undefined) {
            queryParameters['timestamp'] = timestamp;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (correlation !== undefined) {
            queryParameters['correlation'] = correlation;
        }

        if (causeId !== undefined) {
            queryParameters['cause_id'] = causeId;
        }

        if (effectId !== undefined) {
            queryParameters['effect_id'] = effectId;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (numberOfPairs !== undefined) {
            queryParameters['number_of_pairs'] = numberOfPairs;
        }

        if (valuePredictingHighOutcome !== undefined) {
            queryParameters['value_predicting_high_outcome'] = valuePredictingHighOutcome;
        }

        if (valuePredictingLowOutcome !== undefined) {
            queryParameters['value_predicting_low_outcome'] = valuePredictingLowOutcome;
        }

        if (optimalPearsonProduct !== undefined) {
            queryParameters['optimal_pearson_product'] = optimalPearsonProduct;
        }

        if (vote !== undefined) {
            queryParameters['vote'] = vote;
        }

        if (statisticalSignificance !== undefined) {
            queryParameters['statistical_significance'] = statisticalSignificance;
        }

        if (causeUnit !== undefined) {
            queryParameters['cause_unit'] = causeUnit;
        }

        if (causeUnitId !== undefined) {
            queryParameters['cause_unit_id'] = causeUnitId;
        }

        if (causeChanges !== undefined) {
            queryParameters['cause_changes'] = causeChanges;
        }

        if (effectChanges !== undefined) {
            queryParameters['effect_changes'] = effectChanges;
        }

        if (qmScore !== undefined) {
            queryParameters['qm_score'] = qmScore;
        }

        if (error !== undefined) {
            queryParameters['error'] = error;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (reversePearsonCorrelationCoefficient !== undefined) {
            queryParameters['reverse_pearson_correlation_coefficient'] = reversePearsonCorrelationCoefficient;
        }

        if (predictivePearsonCorrelationCoefficient !== undefined) {
            queryParameters['predictive_pearson_correlation_coefficient'] = predictivePearsonCorrelationCoefficient;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_9;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store Correlation
     * Store Correlation
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Correlation that should be stored
     */
    public correlationsPost (accessToken?: string, body?: Correlation) : Promise<{ response: http.ClientResponse; body: inline_response_200_10;  }> {
        const path = this.basePath + '/correlations';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_10;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get Correlation Details
     * Get Correlation
     * @param id id of Correlation
     * @param accessToken User&#39;s OAuth2 access token
     */
    public correlationsIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_10;  }> {
        const path = this.basePath + '/correlations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling correlationsIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_10;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update Correlation
     * Update Correlation
     * @param id id of Correlation
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Correlation that should be updated
     */
    public correlationsIdPut (id: number, accessToken?: string, body?: Correlation) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/correlations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling correlationsIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete Correlation
     * Delete Correlation
     * @param id id of Correlation
     * @param accessToken User&#39;s OAuth2 access token
     */
    public correlationsIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/correlations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling correlationsIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class ConnectionApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all Connections
     * Get all Connections
     * @param accessToken User&#39;s OAuth2 access token
     * @param userId ID of user that owns this correlation
     * @param connectorId The id for the connector data source for which the connection is connected
     * @param connectStatus Indicates whether a connector is currently connected to a service for a user.
     * @param connectError Error message if there is a problem with authorizing this connection.
     * @param updateRequestedAt Time at which an update was requested by a user.
     * @param updateStatus Indicates whether a connector is currently updated.
     * @param updateError Indicates if there was an error during the update.
     * @param lastSuccessfulUpdatedAt The time at which the connector was last successfully updated.
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public connectionsGet (accessToken?: string, userId?: number, connectorId?: number, connectStatus?: string, connectError?: string, updateRequestedAt?: string, updateStatus?: string, updateError?: string, lastSuccessfulUpdatedAt?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_5;  }> {
        const path = this.basePath + '/connections';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (connectStatus !== undefined) {
            queryParameters['connect_status'] = connectStatus;
        }

        if (connectError !== undefined) {
            queryParameters['connect_error'] = connectError;
        }

        if (updateRequestedAt !== undefined) {
            queryParameters['update_requested_at'] = updateRequestedAt;
        }

        if (updateStatus !== undefined) {
            queryParameters['update_status'] = updateStatus;
        }

        if (updateError !== undefined) {
            queryParameters['update_error'] = updateError;
        }

        if (lastSuccessfulUpdatedAt !== undefined) {
            queryParameters['last_successful_updated_at'] = lastSuccessfulUpdatedAt;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_5;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store Connection
     * Store Connection
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Connection that should be stored
     */
    public connectionsPost (accessToken?: string, body?: Connection) : Promise<{ response: http.ClientResponse; body: inline_response_200_6;  }> {
        const path = this.basePath + '/connections';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_6;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get Connection
     * Get Connection
     * @param id id of Connection
     * @param accessToken User&#39;s OAuth2 access token
     */
    public connectionsIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_6;  }> {
        const path = this.basePath + '/connections/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectionsIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_6;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update Connection
     * Update Connection
     * @param id id of Connection
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Connection that should be updated
     */
    public connectionsIdPut (id: number, accessToken?: string, body?: Connection) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/connections/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectionsIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete Connection
     * Delete Connection
     * @param id id of Connection
     * @param accessToken User&#39;s OAuth2 access token
     */
    public connectionsIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/connections/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectionsIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class UnitApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all available units
     * Get all available units
     * @param accessToken User&#39;s OAuth2 access token
     * @param clientId The ID of the client application which last created or updated this unit
     * @param name Unit name
     * @param abbreviatedName Unit abbreviation
     * @param categoryId Unit category ID
     * @param minimumValue Minimum value permitted for this unit
     * @param maximumValue Maximum value permitted for this unit
     * @param updated updated
     * @param defaultUnitId ID of default unit for this units category
     * @param multiply Value multiplied to convert to default unit in this unit category
     * @param add Value which should be added to convert to default unit
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public unitsGet (accessToken?: string, clientId?: string, name?: string, abbreviatedName?: string, categoryId?: number, minimumValue?: number, maximumValue?: number, updated?: number, defaultUnitId?: number, multiply?: number, add?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_21;  }> {
        const path = this.basePath + '/units';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (abbreviatedName !== undefined) {
            queryParameters['abbreviated_name'] = abbreviatedName;
        }

        if (categoryId !== undefined) {
            queryParameters['category_id'] = categoryId;
        }

        if (minimumValue !== undefined) {
            queryParameters['minimum_value'] = minimumValue;
        }

        if (maximumValue !== undefined) {
            queryParameters['maximum_value'] = maximumValue;
        }

        if (updated !== undefined) {
            queryParameters['updated'] = updated;
        }

        if (defaultUnitId !== undefined) {
            queryParameters['default_unit_id'] = defaultUnitId;
        }

        if (multiply !== undefined) {
            queryParameters['multiply'] = multiply;
        }

        if (add !== undefined) {
            queryParameters['add'] = add;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_21;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store Unit
     * Store Unit
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Unit that should be stored
     */
    public unitsPost (accessToken?: string, body?: Unit) : Promise<{ response: http.ClientResponse; body: inline_response_200_22;  }> {
        const path = this.basePath + '/units';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_22;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get Unit
     * Get Unit
     * @param id id of Unit
     * @param accessToken User&#39;s OAuth2 access token
     */
    public unitsIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_22;  }> {
        const path = this.basePath + '/units/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitsIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_22;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update Unit
     * Update Unit
     * @param id id of Unit
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Unit that should be updated
     */
    public unitsIdPut (id: number, accessToken?: string, body?: Unit) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/units/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitsIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete Unit
     * Delete Unit
     * @param id id of Unit
     * @param accessToken User&#39;s OAuth2 access token
     */
    public unitsIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/units/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitsIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class UserVariableApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all UserVariables
     * Get all UserVariables
     * @param accessToken User&#39;s OAuth2 access token
     * @param clientId The ID of the client application which last created or updated this user variable
     * @param parentId ID of the parent variable if this variable has any parent
     * @param variableId ID of variable
     * @param userId User ID
     * @param defaultUnitId D of unit to use for this variable
     * @param minimumAllowedValue Minimum reasonable value for this variable (uses default unit)
     * @param maximumAllowedValue Maximum reasonable value for this variable (uses default unit)
     * @param fillingValue Value for replacing null measurements
     * @param joinWith The Variable this Variable should be joined with. If the variable is joined with some other variable then it is not shown to user in the list of variables
     * @param onsetDelay Estimated number of seconds that pass before a stimulus produces a perceivable effect
     * @param durationOfAction Estimated duration of time following the onset delay in which a stimulus produces a perceivable effect
     * @param variableCategoryId ID of variable category
     * @param updated updated
     * @param _public Is variable public
     * @param causeOnly A value of 1 indicates that this variable is generally a cause in a causal relationship.  An example of a causeOnly variable would be a variable such as Cloud Cover which would generally not be influenced by the behaviour of the user
     * @param fillingType 0 -&gt; No filling, 1 -&gt; Use filling-value
     * @param numberOfMeasurements Number of measurements
     * @param numberOfProcessedMeasurements Number of processed measurements
     * @param measurementsAtLastAnalysis Number of measurements at last analysis
     * @param lastUnitId ID of last Unit
     * @param lastOriginalUnitId ID of last original Unit
     * @param lastOriginalValue Last original value which is stored
     * @param lastValue Last Value
     * @param lastOriginalValue2 Last original value which is stored
     * @param lastSourceId ID of last source
     * @param numberOfCorrelations Number of correlations for this variable
     * @param status status
     * @param errorMessage error_message
     * @param lastSuccessfulUpdateTime When this variable or its settings were last updated
     * @param standardDeviation Standard deviation
     * @param variance Variance
     * @param minimumRecordedValue Minimum recorded value of this variable
     * @param maximumRecordedValue Maximum recorded value of this variable
     * @param mean Mean
     * @param median Median
     * @param mostCommonUnitId Most common Unit ID
     * @param mostCommonValue Most common value
     * @param numberOfUniqueDailyValues Number of unique daily values
     * @param numberOfChanges Number of changes
     * @param skewness Skewness
     * @param kurtosis Kurtosis
     * @param latitude Latitude
     * @param longitude Longitude
     * @param location Location
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param outcome Outcome variables (those with `outcome` == 1) are variables for which a human would generally want to identify the influencing factors.  These include symptoms of illness, physique, mood, cognitive performance, etc.  Generally correlation calculations are only performed on outcome variables
     * @param sources Comma-separated list of source names to limit variables to those sources
     * @param earliestSourceTime Earliest source time
     * @param latestSourceTime Latest source time
     * @param earliestMeasurementTime Earliest measurement time
     * @param latestMeasurementTime Latest measurement time
     * @param earliestFillingTime Earliest filling time
     * @param latestFillingTime Latest filling time
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public userVariablesGet (accessToken?: string, clientId?: string, parentId?: number, variableId?: number, userId?: number, defaultUnitId?: number, minimumAllowedValue?: number, maximumAllowedValue?: number, fillingValue?: number, joinWith?: number, onsetDelay?: number, durationOfAction?: number, variableCategoryId?: number, updated?: number, _public?: number, causeOnly?: boolean, fillingType?: string, numberOfMeasurements?: number, numberOfProcessedMeasurements?: number, measurementsAtLastAnalysis?: number, lastUnitId?: number, lastOriginalUnitId?: number, lastOriginalValue?: number, lastValue?: number, lastOriginalValue2?: number, lastSourceId?: number, numberOfCorrelations?: number, status?: string, errorMessage?: string, lastSuccessfulUpdateTime?: string, standardDeviation?: number, variance?: number, minimumRecordedValue?: number, maximumRecordedValue?: number, mean?: number, median?: number, mostCommonUnitId?: number, mostCommonValue?: number, numberOfUniqueDailyValues?: number, numberOfChanges?: number, skewness?: number, kurtosis?: number, latitude?: number, longitude?: number, location?: string, createdAt?: string, updatedAt?: string, outcome?: boolean, sources?: string, earliestSourceTime?: number, latestSourceTime?: number, earliestMeasurementTime?: number, latestMeasurementTime?: number, earliestFillingTime?: number, latestFillingTime?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_16;  }> {
        const path = this.basePath + '/userVariables';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (parentId !== undefined) {
            queryParameters['parent_id'] = parentId;
        }

        if (variableId !== undefined) {
            queryParameters['variable_id'] = variableId;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (defaultUnitId !== undefined) {
            queryParameters['default_unit_id'] = defaultUnitId;
        }

        if (minimumAllowedValue !== undefined) {
            queryParameters['minimum_allowed_value'] = minimumAllowedValue;
        }

        if (maximumAllowedValue !== undefined) {
            queryParameters['maximum_allowed_value'] = maximumAllowedValue;
        }

        if (fillingValue !== undefined) {
            queryParameters['filling_value'] = fillingValue;
        }

        if (joinWith !== undefined) {
            queryParameters['join_with'] = joinWith;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (variableCategoryId !== undefined) {
            queryParameters['variable_category_id'] = variableCategoryId;
        }

        if (updated !== undefined) {
            queryParameters['updated'] = updated;
        }

        if (_public !== undefined) {
            queryParameters['public'] = _public;
        }

        if (causeOnly !== undefined) {
            queryParameters['cause_only'] = causeOnly;
        }

        if (fillingType !== undefined) {
            queryParameters['filling_type'] = fillingType;
        }

        if (numberOfMeasurements !== undefined) {
            queryParameters['number_of_measurements'] = numberOfMeasurements;
        }

        if (numberOfProcessedMeasurements !== undefined) {
            queryParameters['number_of_processed_measurements'] = numberOfProcessedMeasurements;
        }

        if (measurementsAtLastAnalysis !== undefined) {
            queryParameters['measurements_at_last_analysis'] = measurementsAtLastAnalysis;
        }

        if (lastUnitId !== undefined) {
            queryParameters['last_unit_id'] = lastUnitId;
        }

        if (lastOriginalUnitId !== undefined) {
            queryParameters['last_original_unit_id'] = lastOriginalUnitId;
        }

        if (lastOriginalValue !== undefined) {
            queryParameters['last_original_value'] = lastOriginalValue;
        }

        if (lastValue !== undefined) {
            queryParameters['last_value'] = lastValue;
        }

        if (lastOriginalValue2 !== undefined) {
            queryParameters['last_original_value'] = lastOriginalValue2;
        }

        if (lastSourceId !== undefined) {
            queryParameters['last_source_id'] = lastSourceId;
        }

        if (numberOfCorrelations !== undefined) {
            queryParameters['number_of_correlations'] = numberOfCorrelations;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (errorMessage !== undefined) {
            queryParameters['error_message'] = errorMessage;
        }

        if (lastSuccessfulUpdateTime !== undefined) {
            queryParameters['last_successful_update_time'] = lastSuccessfulUpdateTime;
        }

        if (standardDeviation !== undefined) {
            queryParameters['standard_deviation'] = standardDeviation;
        }

        if (variance !== undefined) {
            queryParameters['variance'] = variance;
        }

        if (minimumRecordedValue !== undefined) {
            queryParameters['minimum_recorded_value'] = minimumRecordedValue;
        }

        if (maximumRecordedValue !== undefined) {
            queryParameters['maximum_recorded_value'] = maximumRecordedValue;
        }

        if (mean !== undefined) {
            queryParameters['mean'] = mean;
        }

        if (median !== undefined) {
            queryParameters['median'] = median;
        }

        if (mostCommonUnitId !== undefined) {
            queryParameters['most_common_unit_id'] = mostCommonUnitId;
        }

        if (mostCommonValue !== undefined) {
            queryParameters['most_common_value'] = mostCommonValue;
        }

        if (numberOfUniqueDailyValues !== undefined) {
            queryParameters['number_of_unique_daily_values'] = numberOfUniqueDailyValues;
        }

        if (numberOfChanges !== undefined) {
            queryParameters['number_of_changes'] = numberOfChanges;
        }

        if (skewness !== undefined) {
            queryParameters['skewness'] = skewness;
        }

        if (kurtosis !== undefined) {
            queryParameters['kurtosis'] = kurtosis;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (location !== undefined) {
            queryParameters['location'] = location;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (outcome !== undefined) {
            queryParameters['outcome'] = outcome;
        }

        if (sources !== undefined) {
            queryParameters['sources'] = sources;
        }

        if (earliestSourceTime !== undefined) {
            queryParameters['earliest_source_time'] = earliestSourceTime;
        }

        if (latestSourceTime !== undefined) {
            queryParameters['latest_source_time'] = latestSourceTime;
        }

        if (earliestMeasurementTime !== undefined) {
            queryParameters['earliest_measurement_time'] = earliestMeasurementTime;
        }

        if (latestMeasurementTime !== undefined) {
            queryParameters['latest_measurement_time'] = latestMeasurementTime;
        }

        if (earliestFillingTime !== undefined) {
            queryParameters['earliest_filling_time'] = earliestFillingTime;
        }

        if (latestFillingTime !== undefined) {
            queryParameters['latest_filling_time'] = latestFillingTime;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_16;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store UserVariable
     * Users can change things like the display name for a variable. They can also change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
     * @param accessToken User&#39;s OAuth2 access token
     * @param body UserVariable that should be stored
     */
    public userVariablesPost (accessToken?: string, body?: UserVariable) : Promise<{ response: http.ClientResponse; body: inline_response_200_26;  }> {
        const path = this.basePath + '/userVariables';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_26;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get UserVariable
     * Get UserVariable
     * @param id id of UserVariable
     * @param accessToken User&#39;s OAuth2 access token
     */
    public userVariablesIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_26;  }> {
        const path = this.basePath + '/userVariables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling userVariablesIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_26;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update UserVariable
     * Update UserVariable
     * @param id id of UserVariable
     * @param accessToken User&#39;s OAuth2 access token
     * @param body UserVariable that should be updated
     */
    public userVariablesIdPut (id: number, accessToken?: string, body?: UserVariable) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/userVariables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling userVariablesIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete UserVariable
     * Delete UserVariable
     * @param id id of UserVariable
     * @param accessToken User&#39;s OAuth2 access token
     */
    public userVariablesIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/userVariables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling userVariablesIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class SourceApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get measurement sources
     * Returns a list of all the apps from which measurement data is obtained.
     * @param accessToken User&#39;s OAuth2 access token
     * @param clientId The ID of the client application which last created or updated this source
     * @param name Name of the application or device
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public sourcesGet (accessToken?: string, clientId?: string, name?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_17;  }> {
        const path = this.basePath + '/sources';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_17;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Add a data source
     * Add a life-tracking app or device to the QuantiModo list of data sources.
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Source that should be stored
     */
    public sourcesPost (accessToken?: string, body?: Source) : Promise<{ response: http.ClientResponse; body: inline_response_200_18;  }> {
        const path = this.basePath + '/sources';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_18;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get Source
     * Get Source
     * @param id id of Source
     * @param accessToken User&#39;s OAuth2 access token
     */
    public sourcesIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_18;  }> {
        const path = this.basePath + '/sources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling sourcesIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_18;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update Source
     * Update Source
     * @param id id of Source
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Source that should be updated
     */
    public sourcesIdPut (id: number, accessToken?: string, body?: Source) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/sources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling sourcesIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete Source
     * Delete Source
     * @param id id of Source
     * @param accessToken User&#39;s OAuth2 access token
     */
    public sourcesIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/sources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling sourcesIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class VariableCategoryApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all VariableCategories
     * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Work.
     * @param accessToken User&#39;s OAuth2 access token
     * @param name Name of the category
     * @param fillingValue Value for replacing null measurements
     * @param maximumAllowedValue Maximum recorded value of this category
     * @param minimumAllowedValue Minimum recorded value of this category
     * @param durationOfAction Estimated number of seconds following the onset delay in which a stimulus produces a perceivable effect
     * @param onsetDelay Estimated number of seconds that pass before a stimulus produces a perceivable effect
     * @param combinationOperation How to combine values of this variable (for instance, to see a summary of the values over a month) SUM or MEAN
     * @param updated updated
     * @param causeOnly A value of 1 indicates that this category is generally a cause in a causal relationship.  An example of a causeOnly category would be a category such as Work which would generally not be influenced by the behaviour of the user
     * @param _public Is category public
     * @param outcome outcome
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param imageUrl Image URL
     * @param defaultUnitId ID of the default unit for the category
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public variableCategoriesGet (accessToken?: string, name?: string, fillingValue?: number, maximumAllowedValue?: number, minimumAllowedValue?: number, durationOfAction?: number, onsetDelay?: number, combinationOperation?: string, updated?: number, causeOnly?: boolean, _public?: number, outcome?: boolean, createdAt?: string, updatedAt?: string, imageUrl?: string, defaultUnitId?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_27;  }> {
        const path = this.basePath + '/variableCategories';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (fillingValue !== undefined) {
            queryParameters['filling_value'] = fillingValue;
        }

        if (maximumAllowedValue !== undefined) {
            queryParameters['maximum_allowed_value'] = maximumAllowedValue;
        }

        if (minimumAllowedValue !== undefined) {
            queryParameters['minimum_allowed_value'] = minimumAllowedValue;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (combinationOperation !== undefined) {
            queryParameters['combination_operation'] = combinationOperation;
        }

        if (updated !== undefined) {
            queryParameters['updated'] = updated;
        }

        if (causeOnly !== undefined) {
            queryParameters['cause_only'] = causeOnly;
        }

        if (_public !== undefined) {
            queryParameters['public'] = _public;
        }

        if (outcome !== undefined) {
            queryParameters['outcome'] = outcome;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (imageUrl !== undefined) {
            queryParameters['image_url'] = imageUrl;
        }

        if (defaultUnitId !== undefined) {
            queryParameters['default_unit_id'] = defaultUnitId;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_27;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store VariableCategory
     * Store VariableCategory
     * @param accessToken User&#39;s OAuth2 access token
     * @param body VariableCategory that should be stored
     */
    public variableCategoriesPost (accessToken?: string, body?: VariableCategory) : Promise<{ response: http.ClientResponse; body: inline_response_200_28;  }> {
        const path = this.basePath + '/variableCategories';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_28;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get VariableCategory
     * Get VariableCategory
     * @param id id of VariableCategory
     * @param accessToken User&#39;s OAuth2 access token
     */
    public variableCategoriesIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_28;  }> {
        const path = this.basePath + '/variableCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableCategoriesIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_28;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update VariableCategory
     * Update VariableCategory
     * @param id id of VariableCategory
     * @param accessToken User&#39;s OAuth2 access token
     * @param body VariableCategory that should be updated
     */
    public variableCategoriesIdPut (id: number, accessToken?: string, body?: VariableCategory) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/variableCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableCategoriesIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete VariableCategory
     * Delete VariableCategory
     * @param id id of VariableCategory
     * @param accessToken User&#39;s OAuth2 access token
     */
    public variableCategoriesIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/variableCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableCategoriesIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class UserVariableRelationshipApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all UserVariableRelationships
     * Get all UserVariableRelationships
     * @param accessToken User&#39;s OAuth2 access token
     * @param id id
     * @param confidenceLevel Our confidence that a consistent predictive relationship exists based on the amount of evidence, reproducibility, and other factors
     * @param confidenceScore A quantitative representation of our confidence that a consistent predictive relationship exists based on the amount of evidence, reproducibility, and other factors
     * @param direction Direction is positive if higher predictor values generally precede higher outcome values. Direction is negative if higher predictor values generally precede lower outcome values.
     * @param durationOfAction Estimated number of seconds following the onset delay in which a stimulus produces a perceivable effect
     * @param errorMessage error_message
     * @param onsetDelay Estimated number of seconds that pass before a stimulus produces a perceivable effect
     * @param outcomeVariableId Variable ID for the outcome variable
     * @param predictorVariableId Variable ID for the predictor variable
     * @param predictorUnitId ID for default unit of the predictor variable
     * @param sinnRank A value representative of the relevance of this predictor relative to other predictors of this outcome.  Usually used for relevancy sorting.
     * @param strengthLevel Can be weak, medium, or strong based on the size of the effect which the predictor appears to have on the outcome relative to other variable relationship strength scores.
     * @param strengthScore A value represented to the size of the effect which the predictor appears to have on the outcome.
     * @param userId user_id
     * @param vote vote
     * @param valuePredictingHighOutcome Value for the predictor variable (in it&#39;s default unit) which typically precedes an above average outcome value
     * @param valuePredictingLowOutcome Value for the predictor variable (in it&#39;s default unit) which typically precedes a below average outcome value
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public userVariableRelationshipsGet (accessToken?: string, id?: number, confidenceLevel?: string, confidenceScore?: number, direction?: string, durationOfAction?: number, errorMessage?: string, onsetDelay?: number, outcomeVariableId?: number, predictorVariableId?: number, predictorUnitId?: number, sinnRank?: number, strengthLevel?: string, strengthScore?: number, userId?: number, vote?: string, valuePredictingHighOutcome?: number, valuePredictingLowOutcome?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_24;  }> {
        const path = this.basePath + '/userVariableRelationships';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        if (confidenceLevel !== undefined) {
            queryParameters['confidence_level'] = confidenceLevel;
        }

        if (confidenceScore !== undefined) {
            queryParameters['confidence_score'] = confidenceScore;
        }

        if (direction !== undefined) {
            queryParameters['direction'] = direction;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (errorMessage !== undefined) {
            queryParameters['error_message'] = errorMessage;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (outcomeVariableId !== undefined) {
            queryParameters['outcome_variable_id'] = outcomeVariableId;
        }

        if (predictorVariableId !== undefined) {
            queryParameters['predictor_variable_id'] = predictorVariableId;
        }

        if (predictorUnitId !== undefined) {
            queryParameters['predictor_unit_id'] = predictorUnitId;
        }

        if (sinnRank !== undefined) {
            queryParameters['sinn_rank'] = sinnRank;
        }

        if (strengthLevel !== undefined) {
            queryParameters['strength_level'] = strengthLevel;
        }

        if (strengthScore !== undefined) {
            queryParameters['strength_score'] = strengthScore;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (vote !== undefined) {
            queryParameters['vote'] = vote;
        }

        if (valuePredictingHighOutcome !== undefined) {
            queryParameters['value_predicting_high_outcome'] = valuePredictingHighOutcome;
        }

        if (valuePredictingLowOutcome !== undefined) {
            queryParameters['value_predicting_low_outcome'] = valuePredictingLowOutcome;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_24;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store UserVariableRelationship
     * Store UserVariableRelationship
     * @param accessToken User&#39;s OAuth2 access token
     * @param body UserVariableRelationship that should be stored
     */
    public userVariableRelationshipsPost (accessToken?: string, body?: UserVariableRelationship) : Promise<{ response: http.ClientResponse; body: inline_response_200_25;  }> {
        const path = this.basePath + '/userVariableRelationships';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_25;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get UserVariableRelationship
     * Get UserVariableRelationship
     * @param id id of UserVariableRelationship
     * @param accessToken User&#39;s OAuth2 access token
     */
    public userVariableRelationshipsIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_25;  }> {
        const path = this.basePath + '/userVariableRelationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling userVariableRelationshipsIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_25;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update UserVariableRelationship
     * Update UserVariableRelationship
     * @param id id of UserVariableRelationship
     * @param accessToken User&#39;s OAuth2 access token
     * @param body UserVariableRelationship that should be updated
     */
    public userVariableRelationshipsIdPut (id: number, accessToken?: string, body?: UserVariableRelationship) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/userVariableRelationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling userVariableRelationshipsIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete UserVariableRelationship
     * Delete UserVariableRelationship
     * @param id id of UserVariableRelationship
     * @param accessToken User&#39;s OAuth2 access token
     */
    public userVariableRelationshipsIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/userVariableRelationships/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling userVariableRelationshipsIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class CredentialApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all Credentials
     * Get all Credentials
     * @param accessToken User&#39;s OAuth2 access token
     * @param userId ID of user that owns this credential
     * @param connectorId The id for the connector data source from which the credential was obtained
     * @param attrKey Attribute name such as token, userid, username, or password
     * @param attrValue Encrypted value for the attribute specified
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public credentialsGet (accessToken?: string, userId?: number, connectorId?: number, attrKey?: string, attrValue?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_11;  }> {
        const path = this.basePath + '/credentials';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (attrKey !== undefined) {
            queryParameters['attr_key'] = attrKey;
        }

        if (attrValue !== undefined) {
            queryParameters['attr_value'] = attrValue;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_11;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store Credential
     * Store Credential
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Credential that should be stored
     */
    public credentialsPost (accessToken?: string, body?: Credential) : Promise<{ response: http.ClientResponse; body: inline_response_200_12;  }> {
        const path = this.basePath + '/credentials';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_12;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get Credential
     * Get Credential
     * @param id connector id
     * @param attrKey attrKey
     * @param accessToken User&#39;s OAuth2 access token
     */
    public credentialsIdGet (id: number, attrKey: string, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_12;  }> {
        const path = this.basePath + '/credentials/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling credentialsIdGet');
        }

        // verify required parameter 'attrKey' is set
        if (!attrKey) {
            throw new Error('Missing required parameter attrKey when calling credentialsIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (attrKey !== undefined) {
            queryParameters['attrKey'] = attrKey;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_12;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update Credential
     * Update Credential
     * @param id connector id
     * @param attrKey attrKey
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Credential that should be updated
     */
    public credentialsIdPut (id: number, attrKey: string, accessToken?: string, body?: Credential) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/credentials/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling credentialsIdPut');
        }

        // verify required parameter 'attrKey' is set
        if (!attrKey) {
            throw new Error('Missing required parameter attrKey when calling credentialsIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (attrKey !== undefined) {
            queryParameters['attrKey'] = attrKey;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete Credential
     * Delete Credential
     * @param id connector id
     * @param attrKey attrKey
     * @param accessToken User&#39;s OAuth2 access token
     */
    public credentialsIdDelete (id: number, attrKey: string, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/credentials/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling credentialsIdDelete');
        }

        // verify required parameter 'attrKey' is set
        if (!attrKey) {
            throw new Error('Missing required parameter attrKey when calling credentialsIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (attrKey !== undefined) {
            queryParameters['attrKey'] = attrKey;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class UnitCategoryApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get unit categories
     * Get a list of the categories of measurement units such as &#39;Distance&#39;, &#39;Duration&#39;, &#39;Energy&#39;, &#39;Frequency&#39;, &#39;Miscellany&#39;, &#39;Pressure&#39;, &#39;Proportion&#39;, &#39;Rating&#39;, &#39;Temperature&#39;, &#39;Volume&#39;, and &#39;Weight&#39;.
     * @param accessToken User&#39;s OAuth2 access token
     * @param name Unit category name
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public unitCategoriesGet (accessToken?: string, name?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_19;  }> {
        const path = this.basePath + '/unitCategories';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_19;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store UnitCategory
     * Store UnitCategory
     * @param accessToken User&#39;s OAuth2 access token
     * @param body UnitCategory that should be stored
     */
    public unitCategoriesPost (accessToken?: string, body?: UnitCategory) : Promise<{ response: http.ClientResponse; body: inline_response_200_20;  }> {
        const path = this.basePath + '/unitCategories';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_20;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get UnitCategory
     * Get UnitCategory
     * @param id id of UnitCategory
     * @param accessToken User&#39;s OAuth2 access token
     */
    public unitCategoriesIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_20;  }> {
        const path = this.basePath + '/unitCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitCategoriesIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_20;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update UnitCategory
     * Update UnitCategory
     * @param id id of UnitCategory
     * @param accessToken User&#39;s OAuth2 access token
     * @param body UnitCategory that should be updated
     */
    public unitCategoriesIdPut (id: number, accessToken?: string, body?: UnitCategory) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/unitCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitCategoriesIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete UnitCategory
     * Delete UnitCategory
     * @param id id of UnitCategory
     * @param accessToken User&#39;s OAuth2 access token
     */
    public unitCategoriesIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/unitCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitCategoriesIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class VoteApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set accessToken(token: string) {
        this.authentications.quantimodo_oauth2.accessToken = token;
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }
    /**
     * Get all Votes
     * Get all Votes
     * @param accessToken User&#39;s OAuth2 access token
     * @param clientId The ID of the client application which last created or updated this vote
     * @param userId ID of the user who voted
     * @param causeId ID of predictor variable
     * @param effectId ID of outcome variable
     * @param value Value of Vote. 1 is for upvote. 0 is for downvote.  Otherwise, there is no vote.
     * @param createdAt When the record was first created. Use ISO 8601 datetime format
     * @param updatedAt When the record was last updated. Use ISO 8601 datetime format
     * @param limit The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param offset OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param sort Sort by given field. If the field is prefixed with &#39;-&#39;, it will sort in descending order.
     */
    public votesGet (accessToken?: string, clientId?: string, userId?: number, causeId?: number, effectId?: number, value?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_33;  }> {
        const path = this.basePath + '/votes';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (causeId !== undefined) {
            queryParameters['cause_id'] = causeId;
        }

        if (effectId !== undefined) {
            queryParameters['effect_id'] = effectId;
        }

        if (value !== undefined) {
            queryParameters['value'] = value;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_33;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Store Vote
     * This is to enable users to indicate their opinion on the plausibility of a causal relationship between a treatment and outcome. QuantiModo incorporates crowd-sourced plausibility estimations into their algorithm. This is done allowing user to indicate their view of the plausibility of each relationship with thumbs up/down buttons placed next to each prediction.
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Vote that should be stored
     */
    public votesPost (accessToken?: string, body?: Vote) : Promise<{ response: http.ClientResponse; body: inline_response_200_34;  }> {
        const path = this.basePath + '/votes';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_34;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Get Vote
     * Get Vote
     * @param id id of Vote
     * @param accessToken User&#39;s OAuth2 access token
     */
    public votesIdGet (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_34;  }> {
        const path = this.basePath + '/votes/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling votesIdGet');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_34;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Update Vote
     * Update Vote
     * @param id id of Vote
     * @param accessToken User&#39;s OAuth2 access token
     * @param body Vote that should be updated
     */
    public votesIdPut (id: number, accessToken?: string, body?: Vote) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/votes/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling votesIdPut');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
    /**
     * Delete Vote
     * Delete previously posted vote
     * @param id id of Vote
     * @param accessToken User&#39;s OAuth2 access token
     */
    public votesIdDelete (id: number, accessToken?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.basePath + '/votes/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling votesIdDelete');
        }

        if (accessToken !== undefined) {
            queryParameters['access_token'] = accessToken;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
