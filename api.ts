import request = require('request');
import promise = require('bluebird');
import http = require('http');

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class MeasurementValue {
    /**
    * start_time
    */
    startTime: number;
    /**
    * value
    */
    value: number;
}

export class MeasurementPost {
    /**
    * variable_id
    */
    variableId: number;
    /**
    * source_id
    */
    sourceId: number;
    /**
    * unit_id
    */
    unitId: number;
    /**
    * measurements
    */
    measurements: Array<MeasurementValue>;
}

export class AggregatedCorrelation {
    /**
    * id
    */
    id: number;
    /**
    * correlation
    */
    correlation: number;
    /**
    * cause_id
    */
    causeId: number;
    /**
    * effect_id
    */
    effectId: number;
    /**
    * onset_delay
    */
    onsetDelay: number;
    /**
    * duration_of_action
    */
    durationOfAction: number;
    /**
    * number_of_pairs
    */
    numberOfPairs: number;
    /**
    * value_predicting_high_outcome
    */
    valuePredictingHighOutcome: number;
    /**
    * value_predicting_low_outcome
    */
    valuePredictingLowOutcome: number;
    /**
    * optimal_pearson_product
    */
    optimalPearsonProduct: number;
    /**
    * vote
    */
    vote: number;
    /**
    * number_of_users
    */
    numberOfUsers: number;
    /**
    * number_of_correlations
    */
    numberOfCorrelations: number;
    /**
    * statistical_significance
    */
    statisticalSignificance: number;
    /**
    * cause_unit
    */
    causeUnit: string;
    /**
    * cause_unit_id
    */
    causeUnitId: number;
    /**
    * cause_changes
    */
    causeChanges: number;
    /**
    * effect_changes
    */
    effectChanges: number;
    /**
    * aggregate_qm_score
    */
    aggregateQmScore: number;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
    /**
    * status
    */
    status: string;
    /**
    * error_message
    */
    errorMessage: string;
    /**
    * last_successful_update_time
    */
    lastSuccessfulUpdateTime: Date;
    /**
    * reverse_pearson_correlation_coefficient
    */
    reversePearsonCorrelationCoefficient: number;
    /**
    * predictive_pearson_correlation_coefficient
    */
    predictivePearsonCorrelationCoefficient: number;
}

export class Connection {
    /**
    * id
    */
    id: number;
    /**
    * user_id
    */
    userId: number;
    /**
    * connector_id
    */
    connectorId: number;
    /**
    * connect_status
    */
    connectStatus: string;
    /**
    * connect_error
    */
    connectError: string;
    /**
    * update_requested_at
    */
    updateRequestedAt: Date;
    /**
    * update_status
    */
    updateStatus: string;
    /**
    * update_error
    */
    updateError: string;
    /**
    * last_successful_updated_at
    */
    lastSuccessfulUpdatedAt: Date;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
}

export class Connector {
    /**
    * Connector ID number
    */
    id: number;
    /**
    * Connector lowercase system name
    */
    name: string;
    /**
    * Connector pretty display name
    */
    displayName: string;
    /**
    * URL to the image of the connector logo
    */
    image: string;
    /**
    * URL to a site where one can get this device or application
    */
    getItUrl: string;
    /**
    * Short description
    */
    shortDescription: string;
    /**
    * Long description
    */
    longDescription: string;
    /**
    * enabled
    */
    enabled: boolean;
    /**
    * oauth
    */
    oauth: boolean;
}

export class Correlation {
    /**
    * id
    */
    id: number;
    /**
    * Time at which correlation was calculated
    */
    timestamp: number;
    /**
    * ID of user that owns this correlation
    */
    userId: number;
    /**
    * Pearson correlation coefficient between cause and effect measurements
    */
    correlation: number;
    /**
    * variable ID of the cause variable for which the user desires correlations
    */
    causeId: number;
    /**
    * variable ID of the effect variable for which the user desires correlations
    */
    effectId: number;
    /**
    * User estimated or default time after cause measurement before a perceivable effect is observed
    */
    onsetDelay: number;
    /**
    * Time over which the cause is expected to produce a perceivable effect following the onset delay
    */
    durationOfAction: number;
    /**
    * Number of points that went into the correlation calculation
    */
    numberOfPairs: number;
    /**
    * cause value that predicts an above average effect value (in default unit for cause variable)
    */
    valuePredictingHighOutcome: number;
    /**
    * cause value that predicts a below average effect value (in default unit for cause variable)
    */
    valuePredictingLowOutcome: number;
    /**
    * Optimal Pearson Product
    */
    optimalPearsonProduct: number;
    /**
    * Vote
    */
    vote: number;
    /**
    * A function of the effect size and sample size
    */
    statisticalSignificance: number;
    /**
    * Unit of Cause
    */
    causeUnit: string;
    /**
    * Unit ID of Cause
    */
    causeUnitId: number;
    /**
    * Cause changes
    */
    causeChanges: number;
    /**
    * Effect changes
    */
    effectChanges: number;
    /**
    * QM Score
    */
    qmScore: number;
    /**
    * error
    */
    error: string;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
    /**
    * Correlation when cause and effect are reversed. For any causal relationship, the forward correlation should exceed the reverse correlation
    */
    reversePearsonCorrelationCoefficient: number;
    /**
    * Predictive Pearson Correlation Coefficient
    */
    predictivePearsonCorrelationCoefficient: number;
}

export class Credential {
    /**
    * connector_id
    */
    connectorId: number;
    /**
    * attr_key
    */
    attrKey: string;
    /**
    * attr_value
    */
    attrValue: string;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
}

export class Measurement {
    /**
    * id
    */
    id: number;
    /**
    * ID of user that owns this measurement
    */
    userId: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * Connector ID
    */
    connectorId: number;
    /**
    * ID of the variable for which we are creating the measurement records
    */
    variableId: number;
    /**
    * Application or device used to record the measurement values
    */
    sourceId: number;
    /**
    * Start Time for the measurement event in ISO 8601
    */
    startTime: number;
    /**
    * Converted measurement value in requested unit
    */
    value: number;
    /**
    * Unit ID of measurement as requested in GET request
    */
    unitId: number;
    /**
    * Original value
    */
    originalValue: number;
    /**
    * Unit ID of measurement as originally submitted
    */
    originalUnitId: number;
    /**
    * duration of measurement in seconds
    */
    duration: number;
    /**
    * Note of measurement
    */
    note: string;
    /**
    * latitude
    */
    latitude: number;
    /**
    * longitude
    */
    longitude: number;
    /**
    * location
    */
    location: string;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
    /**
    * error
    */
    error: string;
}

export class MeasurementExport {
    /**
    * id
    */
    id: number;
    /**
    * ID of User
    */
    userId: number;
    /**
    * Status of Measurement Export
    */
    status: string;
    /**
    * Error message
    */
    errorMessage: string;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
}

export class Source {
    /**
    * id
    */
    id: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * Name of the application or device
    */
    name: string;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
}

export class Unit {
    /**
    * id
    */
    id: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * Unit name
    */
    name: string;
    /**
    * Unit abbreviation
    */
    abbreviatedName: string;
    /**
    * Unit category ID
    */
    categoryId: number;
    /**
    * Unit minimum value
    */
    minimumValue: number;
    /**
    * Unit maximum value
    */
    maximumValue: number;
    /**
    * updated
    */
    updated: number;
    /**
    * ID of default unit
    */
    defaultUnitId: number;
    /**
    * Value multiplied to
    */
    multiply: number;
    /**
    * Value which should be added to convert to default unit
    */
    add: number;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
}

export class UnitCategory {
    /**
    * id
    */
    id: number;
    /**
    * Unit category name
    */
    name: string;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
}

export class UnitConversion {
    /**
    * unit_id
    */
    unitId: number;
    /**
    * step in the conversion process
    */
    stepNumber: boolean;
    /**
    * 0 is add and 1 is multiply
    */
    operation: boolean;
    /**
    * number used in the operation
    */
    value: number;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
}

export class Update {
    /**
    * id
    */
    id: number;
    /**
    * user_id
    */
    userId: number;
    /**
    * connector_id
    */
    connectorId: number;
    /**
    * number_of_measurements
    */
    numberOfMeasurements: number;
    /**
    * success
    */
    success: boolean;
    /**
    * message
    */
    message: string;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
}

export class UserVariable {
    /**
    * ID of the parent variable if this variable has any parent
    */
    parentId: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * ID of variable
    */
    variableId: number;
    /**
    * ID of unit to use for this variable
    */
    defaultUnitId: number;
    /**
    * Minimum reasonable value for this variable (uses default unit)
    */
    minimumAllowedValue: number;
    /**
    * Maximum reasonable value for this variable (uses default unit)
    */
    maximumAllowedValue: number;
    /**
    * Value for replacing null measurements
    */
    fillingValue: number;
    /**
    * The Variable this Variable should be joined with. If the variable is joined with some other variable then it is not shown to user in the list of variables
    */
    joinWith: number;
    /**
    * How long it takes for a measurement in this variable to take effect
    */
    onsetDelay: number;
    /**
    * Estimated duration of time following the onset delay in which a stimulus produces a perceivable effect
    */
    durationOfAction: number;
    /**
    * ID of variable category
    */
    variableCategoryId: number;
    /**
    * updated
    */
    updated: number;
    /**
    * Is variable public
    */
    _public: number;
    /**
    * A value of 1 indicates that this variable is generally a cause in a causal relationship.  An example of a causeOnly variable would be a variable such as Cloud Cover which would generally not be influenced by the behaviour of the user
    */
    causeOnly: boolean;
    /**
    * 0 -> No filling, 1 -> Use filling-value
    */
    fillingType: string;
    /**
    * Number of measurements
    */
    numberOfMeasurements: number;
    /**
    * Number of processed measurements
    */
    numberOfProcessedMeasurements: number;
    /**
    * Number of measurements at last analysis
    */
    measurementsAtLastAnalysis: number;
    /**
    * ID of last Unit
    */
    lastUnitId: number;
    /**
    * ID of last original Unit
    */
    lastOriginalUnitId: number;
    /**
    * Last Value
    */
    lastValue: number;
    /**
    * Last original value which is stored
    */
    lastOriginalValue: number;
    /**
    * ID of last source
    */
    lastSourceId: number;
    /**
    * Number of correlations for this variable
    */
    numberOfCorrelations: number;
    /**
    * status
    */
    status: string;
    /**
    * error_message
    */
    errorMessage: string;
    /**
    * When this variable or its settings were last updated
    */
    lastSuccessfulUpdateTime: Date;
    /**
    * Standard deviation
    */
    standardDeviation: number;
    /**
    * Variance
    */
    variance: number;
    /**
    * Minimum recorded daily value of this variable
    */
    minimumRecordedDailyValue: number;
    /**
    * Maximum recorded daily value of this variable
    */
    maximumRecordedDailyValue: number;
    /**
    * Mean
    */
    mean: number;
    /**
    * Median
    */
    median: number;
    /**
    * Most common Unit ID
    */
    mostCommonUnitId: number;
    /**
    * Most common value
    */
    mostCommonValue: number;
    /**
    * Number of unique daily values
    */
    numberOfUniqueDailyValues: number;
    /**
    * Number of changes
    */
    numberOfChanges: number;
    /**
    * Skewness
    */
    skewness: number;
    /**
    * Kurtosis
    */
    kurtosis: number;
    /**
    * Latitude
    */
    latitude: number;
    /**
    * Longitude
    */
    longitude: number;
    /**
    * Location
    */
    location: string;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
    /**
    * Outcome variables (those with `outcome` == 1) are variables for which a human would generally want to identify the influencing factors.  These include symptoms of illness, physique, mood, cognitive performance, etc.  Generally correlation calculations are only performed on outcome variables
    */
    outcome: boolean;
    /**
    * Comma-separated list of source names to limit variables to those sources
    */
    sources: string;
    /**
    * Earliest source time
    */
    earliestSourceTime: number;
    /**
    * Latest source time
    */
    latestSourceTime: number;
    /**
    * Earliest measurement time
    */
    earliestMeasurementTime: number;
    /**
    * Latest measurement time
    */
    latestMeasurementTime: number;
    /**
    * Earliest filling time
    */
    earliestFillingTime: number;
    /**
    * Latest filling time
    */
    latestFillingTime: number;
}

export class Variable {
    /**
    * id
    */
    id: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * parent_id
    */
    parentId: number;
    /**
    * Name of the variable
    */
    name: string;
    /**
    * Category of the variable
    */
    variableCategoryId: number;
    /**
    * ID of the default unit of measurement to use for this variable
    */
    defaultUnitId: number;
    /**
    * How to combine values of this variable (for instance, to see a summary of the values over a month) 0 for sum OR 1 for mean
    */
    combinationOperation: string;
    /**
    * filling_value
    */
    fillingValue: number;
    /**
    * maximum_allowed_value
    */
    maximumAllowedValue: number;
    /**
    * minimum_allowed_value
    */
    minimumAllowedValue: number;
    /**
    * onset_delay
    */
    onsetDelay: number;
    /**
    * duration_of_action
    */
    durationOfAction: number;
    /**
    * public
    */
    _public: number;
    /**
    * cause_only
    */
    causeOnly: boolean;
    /**
    * most_common_value
    */
    mostCommonValue: number;
    /**
    * most_common_unit_id
    */
    mostCommonUnitId: number;
    /**
    * standard_deviation
    */
    standardDeviation: number;
    /**
    * variance
    */
    variance: number;
    /**
    * mean
    */
    mean: number;
    /**
    * median
    */
    median: number;
    /**
    * number_of_measurements
    */
    numberOfMeasurements: number;
    /**
    * number_of_unique_values
    */
    numberOfUniqueValues: number;
    /**
    * skewness
    */
    skewness: number;
    /**
    * kurtosis
    */
    kurtosis: number;
    /**
    * status
    */
    status: string;
    /**
    * error_message
    */
    errorMessage: string;
    /**
    * last_successful_update_time
    */
    lastSuccessfulUpdateTime: Date;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
    /**
    * product_url
    */
    productUrl: string;
    /**
    * image_url
    */
    imageUrl: string;
    /**
    * price
    */
    price: number;
    /**
    * number_of_user_variables
    */
    numberOfUserVariables: number;
    /**
    * outcome
    */
    outcome: boolean;
    /**
    * minimum_recorded_value
    */
    minimumRecordedValue: number;
    /**
    * maximum_recorded_value
    */
    maximumRecordedValue: number;
}

export class VariableCategory {
    /**
    * id
    */
    id: number;
    /**
    * Name of the category
    */
    name: string;
    /**
    * Value for replacing null measurements
    */
    fillingValue: number;
    /**
    * Maximum recorded value of this category
    */
    maximumAllowedValue: number;
    /**
    * Minimum recorded value of this category
    */
    minimumAllowedValue: number;
    /**
    * How long the effect of a measurement in this variable lasts
    */
    durationOfAction: number;
    /**
    * How long it takes for a measurement in this variable to take effect
    */
    onsetDelay: number;
    /**
    * How to combine values of this variable (for instance, to see a summary of the values over a month) 0 for sum OR 1 for mean
    */
    combinationOperation: string;
    /**
    * updated
    */
    updated: number;
    /**
    * A value of 1 indicates that this category is generally a cause in a causal relationship.  An example of a causeOnly category would be a category such as Work which would generally not be influenced by the behaviour of the user
    */
    causeOnly: boolean;
    /**
    * Is category public
    */
    _public: number;
    /**
    * outcome
    */
    outcome: boolean;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
    /**
    * Image URL
    */
    imageUrl: string;
    /**
    * ID of the default unit for the category
    */
    defaultUnitId: number;
}

export class VariableUserSource {
    /**
    * ID of User
    */
    userId: number;
    /**
    * ID of variable
    */
    variableId: number;
    /**
    * ID of source
    */
    sourceId: number;
    /**
    * Time that this measurement occurred Uses epoch minute (epoch time divided by 60)
    */
    timestamp: number;
    /**
    * Earliest measurement time
    */
    earliestMeasurementTime: number;
    /**
    * Latest measurement time
    */
    latestMeasurementTime: number;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
}

export class Vote {
    /**
    * id
    */
    id: number;
    /**
    * client_id
    */
    clientId: string;
    /**
    * ID of User
    */
    userId: number;
    /**
    * ID of cause variable
    */
    causeId: number;
    /**
    * ID of effect variable
    */
    effectId: number;
    /**
    * Value of Vote
    */
    value: number;
    /**
    * created_at
    */
    createdAt: Date;
    /**
    * updated_at
    */
    updatedAt: Date;
}

export class InlineResponse200 {
    data: Array<AggregatedCorrelation>;
    success: boolean;
}

export class InlineResponse2001 {
    data: AggregatedCorrelation;
    success: boolean;
}

export class InlineResponse2002 {
    data: string;
    success: boolean;
}

export class InlineResponse2003 {
    data: Array<Connection>;
    success: boolean;
}

export class InlineResponse2004 {
    data: Connection;
    success: boolean;
}

export class InlineResponse2005 {
    data: Array<Connector>;
    success: boolean;
}

export class InlineResponse2006 {
    data: Connector;
    success: boolean;
}

export class InlineResponse2007 {
    data: Array<Correlation>;
    success: boolean;
}

export class InlineResponse2008 {
    data: Correlation;
    success: boolean;
}

export class InlineResponse2009 {
    data: Array<Credential>;
    success: boolean;
}

export class InlineResponse20010 {
    data: Credential;
    success: boolean;
}

export class InlineResponse20011 {
    data: Array<Measurement>;
    success: boolean;
}

export class InlineResponse20012 {
    data: Measurement;
    success: boolean;
}

export class InlineResponse20013 {
    data: Array<Source>;
    success: boolean;
}

export class InlineResponse20014 {
    data: Source;
    success: boolean;
}

export class InlineResponse20015 {
    data: Array<UnitCategory>;
    success: boolean;
}

export class InlineResponse20016 {
    data: UnitCategory;
    success: boolean;
}

export class InlineResponse20017 {
    data: Array<Unit>;
    success: boolean;
}

export class InlineResponse20018 {
    data: Unit;
    success: boolean;
}

export class InlineResponse20019 {
    data: Array<Update>;
    success: boolean;
}

export class InlineResponse20020 {
    data: Update;
    success: boolean;
}

export class InlineResponse20021 {
    data: Array<UserVariable>;
    success: boolean;
}

export class InlineResponse20022 {
    data: UserVariable;
    success: boolean;
}

export class InlineResponse20023 {
    data: Array<VariableCategory>;
    success: boolean;
}

export class InlineResponse20024 {
    data: VariableCategory;
    success: boolean;
}

export class InlineResponse20025 {
    data: Array<VariableUserSource>;
    success: boolean;
}

export class InlineResponse20026 {
    data: VariableUserSource;
    success: boolean;
}

export class InlineResponse20027 {
    data: Array<Variable>;
    success: boolean;
}

export class InlineResponse20028 {
    data: Variable;
    success: boolean;
}

export class InlineResponse20029 {
    data: Array<Vote>;
    success: boolean;
}

export class InlineResponse20030 {
    data: Vote;
    success: boolean;
}


interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header") {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

class OAuth implements Authentication {
    applyToRequest(requestOptions: request.Options): void {
        // TODO: support oauth
    }
}

class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        // Do nothing
    }
}

export class VariableUserSourceApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public variableUserSourcesGet (variableId?: number, userId?: number, timestamp?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_25;  }> {
        const path = this.url + this.basePath + '/variableUserSources';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (variableId !== undefined) {
            queryParameters['variable_id'] = variableId;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (timestamp !== undefined) {
            queryParameters['timestamp'] = timestamp;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_25;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variableUserSourcesPost (body?: VariableUserSource) : Promise<{ response: http.ClientResponse; body: inline_response_200_26;  }> {
        const path = this.url + this.basePath + '/variableUserSources';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_26;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variableUserSourcesIdGet (id: number, sourceId: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_26;  }> {
        const path = this.url + this.basePath + '/variableUserSources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableUserSourcesIdGet');
        }

        // verify required parameter 'sourceId' is set
        if (!sourceId) {
            throw new Error('Missing required parameter sourceId when calling variableUserSourcesIdGet');
        }

        if (sourceId !== undefined) {
            queryParameters['source_id'] = sourceId;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_26;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variableUserSourcesIdPut (id: number, sourceId: number, body?: VariableUserSource) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/variableUserSources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableUserSourcesIdPut');
        }

        // verify required parameter 'sourceId' is set
        if (!sourceId) {
            throw new Error('Missing required parameter sourceId when calling variableUserSourcesIdPut');
        }

        if (sourceId !== undefined) {
            queryParameters['source_id'] = sourceId;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variableUserSourcesIdDelete (id: number, sourceId: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/variableUserSources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableUserSourcesIdDelete');
        }

        // verify required parameter 'sourceId' is set
        if (!sourceId) {
            throw new Error('Missing required parameter sourceId when calling variableUserSourcesIdDelete');
        }

        if (sourceId !== undefined) {
            queryParameters['source_id'] = sourceId;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class MeasurementApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public measurementsGet (userId?: number, clientId?: string, connectorId?: number, variableId?: number, startTime?: number, value?: number, originalValue?: number, duration?: number, note?: string, latitude?: number, longitude?: number, location?: string, createdAt?: string, updatedAt?: string, error?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_11;  }> {
        const path = this.url + this.basePath + '/measurements';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (variableId !== undefined) {
            queryParameters['variable_id'] = variableId;
        }

        if (startTime !== undefined) {
            queryParameters['start_time'] = startTime;
        }

        if (value !== undefined) {
            queryParameters['value'] = value;
        }

        if (originalValue !== undefined) {
            queryParameters['original_value'] = originalValue;
        }

        if (duration !== undefined) {
            queryParameters['duration'] = duration;
        }

        if (note !== undefined) {
            queryParameters['note'] = note;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (location !== undefined) {
            queryParameters['location'] = location;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (error !== undefined) {
            queryParameters['error'] = error;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_11;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public measurementsPost (body?: MeasurementPost) : Promise<{ response: http.ClientResponse; body: inline_response_200_11;  }> {
        const path = this.url + this.basePath + '/measurements';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_11;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public measurementsCsvGet () : Promise<{ response: http.ClientResponse; body: any;  }> {
        const path = this.url + this.basePath + '/measurements/csv';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: any;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public measurementsRequestCsvPost () : Promise<{ response: http.ClientResponse; body: number;  }> {
        const path = this.url + this.basePath + '/measurements/request_csv';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: number;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public measurementsIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_12;  }> {
        const path = this.url + this.basePath + '/measurements/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling measurementsIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_12;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public measurementsIdPut (id: number, body?: Measurement) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/measurements/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling measurementsIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public measurementsIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/measurements/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling measurementsIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class VariableApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public variablesGet (id?: number, clientId?: string, parentId?: number, name?: string, variableCategoryId?: number, defaultUnitId?: number, combinationOperation?: string, fillingValue?: number, maximumAllowedValue?: number, minimumAllowedValue?: number, onsetDelay?: number, durationOfAction?: number, _public?: number, causeOnly?: boolean, mostCommonValue?: number, mostCommonUnitId?: number, standardDeviation?: number, variance?: number, mean?: number, median?: number, numberOfMeasurements?: number, numberOfUniqueValues?: number, skewness?: number, kurtosis?: number, latitude?: number, longitude?: number, location?: string, status?: string, errorMessage?: string, lastSuccessfulUpdateTime?: string, createdAt?: string, updatedAt?: string, productUrl?: string, imageUrl?: string, price?: number, numberOfUserVariables?: number, outcome?: boolean, minimumRecordedValue?: number, maximumRecordedValue?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_27;  }> {
        const path = this.url + this.basePath + '/variables';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (id !== undefined) {
            queryParameters['id'] = id;
        }

        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (parentId !== undefined) {
            queryParameters['parent_id'] = parentId;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (variableCategoryId !== undefined) {
            queryParameters['variable_category_id'] = variableCategoryId;
        }

        if (defaultUnitId !== undefined) {
            queryParameters['default_unit_id'] = defaultUnitId;
        }

        if (combinationOperation !== undefined) {
            queryParameters['combination_operation'] = combinationOperation;
        }

        if (fillingValue !== undefined) {
            queryParameters['filling_value'] = fillingValue;
        }

        if (maximumAllowedValue !== undefined) {
            queryParameters['maximum_allowed_value'] = maximumAllowedValue;
        }

        if (minimumAllowedValue !== undefined) {
            queryParameters['minimum_allowed_value'] = minimumAllowedValue;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (_public !== undefined) {
            queryParameters['public'] = _public;
        }

        if (causeOnly !== undefined) {
            queryParameters['cause_only'] = causeOnly;
        }

        if (mostCommonValue !== undefined) {
            queryParameters['most_common_value'] = mostCommonValue;
        }

        if (mostCommonUnitId !== undefined) {
            queryParameters['most_common_unit_id'] = mostCommonUnitId;
        }

        if (standardDeviation !== undefined) {
            queryParameters['standard_deviation'] = standardDeviation;
        }

        if (variance !== undefined) {
            queryParameters['variance'] = variance;
        }

        if (mean !== undefined) {
            queryParameters['mean'] = mean;
        }

        if (median !== undefined) {
            queryParameters['median'] = median;
        }

        if (numberOfMeasurements !== undefined) {
            queryParameters['number_of_measurements'] = numberOfMeasurements;
        }

        if (numberOfUniqueValues !== undefined) {
            queryParameters['number_of_unique_values'] = numberOfUniqueValues;
        }

        if (skewness !== undefined) {
            queryParameters['skewness'] = skewness;
        }

        if (kurtosis !== undefined) {
            queryParameters['kurtosis'] = kurtosis;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (location !== undefined) {
            queryParameters['location'] = location;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (errorMessage !== undefined) {
            queryParameters['error_message'] = errorMessage;
        }

        if (lastSuccessfulUpdateTime !== undefined) {
            queryParameters['last_successful_update_time'] = lastSuccessfulUpdateTime;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (productUrl !== undefined) {
            queryParameters['product_url'] = productUrl;
        }

        if (imageUrl !== undefined) {
            queryParameters['image_url'] = imageUrl;
        }

        if (price !== undefined) {
            queryParameters['price'] = price;
        }

        if (numberOfUserVariables !== undefined) {
            queryParameters['number_of_user_variables'] = numberOfUserVariables;
        }

        if (outcome !== undefined) {
            queryParameters['outcome'] = outcome;
        }

        if (minimumRecordedValue !== undefined) {
            queryParameters['minimum_recorded_value'] = minimumRecordedValue;
        }

        if (maximumRecordedValue !== undefined) {
            queryParameters['maximum_recorded_value'] = maximumRecordedValue;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_27;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variablesPost (body?: Variable) : Promise<{ response: http.ClientResponse; body: inline_response_200_28;  }> {
        const path = this.url + this.basePath + '/variables';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_28;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variablesIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_28;  }> {
        const path = this.url + this.basePath + '/variables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variablesIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_28;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variablesIdPut (id: number, body?: Variable) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/variables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variablesIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variablesIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/variables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variablesIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class UpdateApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public updatesGet (userId?: number, connectorId?: number, numberOfMeasurements?: number, success?: boolean, message?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_19;  }> {
        const path = this.url + this.basePath + '/updates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (numberOfMeasurements !== undefined) {
            queryParameters['number_of_measurements'] = numberOfMeasurements;
        }

        if (success !== undefined) {
            queryParameters['success'] = success;
        }

        if (message !== undefined) {
            queryParameters['message'] = message;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_19;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public updatesPost (body?: Update) : Promise<{ response: http.ClientResponse; body: inline_response_200_20;  }> {
        const path = this.url + this.basePath + '/updates';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_20;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public updatesIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_20;  }> {
        const path = this.url + this.basePath + '/updates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling updatesIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_20;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public updatesIdPut (id: number, body?: Update) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/updates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling updatesIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public updatesIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/updates/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling updatesIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class AggregatedCorrelationApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public aggregatedCorrelationsGet (correlation?: number, causeId?: number, effectId?: number, onsetDelay?: number, durationOfAction?: number, numberOfPairs?: number, valuePredictingHighOutcome?: number, valuePredictingLowOutcome?: number, optimalPearsonProduct?: number, vote?: number, numberOfUsers?: number, numberOfCorrelations?: number, statisticalSignificance?: number, causeUnit?: string, causeUnitId?: number, causeChanges?: number, effectChanges?: number, aggregateQmScore?: number, createdAt?: string, updatedAt?: string, status?: string, errorMessage?: string, lastSuccessfulUpdateTime?: string, reversePearsonCorrelationCoefficient?: number, predictivePearsonCorrelationCoefficient?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200;  }> {
        const path = this.url + this.basePath + '/aggregatedCorrelations';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (correlation !== undefined) {
            queryParameters['correlation'] = correlation;
        }

        if (causeId !== undefined) {
            queryParameters['cause_id'] = causeId;
        }

        if (effectId !== undefined) {
            queryParameters['effect_id'] = effectId;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (numberOfPairs !== undefined) {
            queryParameters['number_of_pairs'] = numberOfPairs;
        }

        if (valuePredictingHighOutcome !== undefined) {
            queryParameters['value_predicting_high_outcome'] = valuePredictingHighOutcome;
        }

        if (valuePredictingLowOutcome !== undefined) {
            queryParameters['value_predicting_low_outcome'] = valuePredictingLowOutcome;
        }

        if (optimalPearsonProduct !== undefined) {
            queryParameters['optimal_pearson_product'] = optimalPearsonProduct;
        }

        if (vote !== undefined) {
            queryParameters['vote'] = vote;
        }

        if (numberOfUsers !== undefined) {
            queryParameters['number_of_users'] = numberOfUsers;
        }

        if (numberOfCorrelations !== undefined) {
            queryParameters['number_of_correlations'] = numberOfCorrelations;
        }

        if (statisticalSignificance !== undefined) {
            queryParameters['statistical_significance'] = statisticalSignificance;
        }

        if (causeUnit !== undefined) {
            queryParameters['cause_unit'] = causeUnit;
        }

        if (causeUnitId !== undefined) {
            queryParameters['cause_unit_id'] = causeUnitId;
        }

        if (causeChanges !== undefined) {
            queryParameters['cause_changes'] = causeChanges;
        }

        if (effectChanges !== undefined) {
            queryParameters['effect_changes'] = effectChanges;
        }

        if (aggregateQmScore !== undefined) {
            queryParameters['aggregate_qm_score'] = aggregateQmScore;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (errorMessage !== undefined) {
            queryParameters['error_message'] = errorMessage;
        }

        if (lastSuccessfulUpdateTime !== undefined) {
            queryParameters['last_successful_update_time'] = lastSuccessfulUpdateTime;
        }

        if (reversePearsonCorrelationCoefficient !== undefined) {
            queryParameters['reverse_pearson_correlation_coefficient'] = reversePearsonCorrelationCoefficient;
        }

        if (predictivePearsonCorrelationCoefficient !== undefined) {
            queryParameters['predictive_pearson_correlation_coefficient'] = predictivePearsonCorrelationCoefficient;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public aggregatedCorrelationsPost (body?: AggregatedCorrelation) : Promise<{ response: http.ClientResponse; body: inline_response_200_1;  }> {
        const path = this.url + this.basePath + '/aggregatedCorrelations';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_1;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public aggregatedCorrelationsIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_1;  }> {
        const path = this.url + this.basePath + '/aggregatedCorrelations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling aggregatedCorrelationsIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_1;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public aggregatedCorrelationsIdPut (id: number, body?: AggregatedCorrelation) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/aggregatedCorrelations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling aggregatedCorrelationsIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public aggregatedCorrelationsIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/aggregatedCorrelations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling aggregatedCorrelationsIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class ConnectorApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public connectorsGet (name?: string, displayName?: string, image?: string, getItUrl?: string, shortDescription?: string, longDescription?: string, enabled?: boolean, oauth?: boolean, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_5;  }> {
        const path = this.url + this.basePath + '/connectors';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (displayName !== undefined) {
            queryParameters['display_name'] = displayName;
        }

        if (image !== undefined) {
            queryParameters['image'] = image;
        }

        if (getItUrl !== undefined) {
            queryParameters['get_it_url'] = getItUrl;
        }

        if (shortDescription !== undefined) {
            queryParameters['short_description'] = shortDescription;
        }

        if (longDescription !== undefined) {
            queryParameters['long_description'] = longDescription;
        }

        if (enabled !== undefined) {
            queryParameters['enabled'] = enabled;
        }

        if (oauth !== undefined) {
            queryParameters['oauth'] = oauth;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_5;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public connectorsPost (body?: Connector) : Promise<{ response: http.ClientResponse; body: inline_response_200_6;  }> {
        const path = this.url + this.basePath + '/connectors';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_6;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public connectorsIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_6;  }> {
        const path = this.url + this.basePath + '/connectors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectorsIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_6;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public connectorsIdPut (id: number, body?: Connector) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/connectors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectorsIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public connectorsIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/connectors/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectorsIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class CorrelationApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public correlationsGet (timestamp?: number, userId?: number, correlation?: number, causeId?: number, effectId?: number, onsetDelay?: number, durationOfAction?: number, numberOfPairs?: number, valuePredictingHighOutcome?: number, valuePredictingLowOutcome?: number, optimalPearsonProduct?: number, vote?: number, statisticalSignificance?: number, causeUnit?: string, causeUnitId?: number, causeChanges?: number, effectChanges?: number, qmScore?: number, error?: string, createdAt?: string, updatedAt?: string, reversePearsonCorrelationCoefficient?: number, predictivePearsonCorrelationCoefficient?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_7;  }> {
        const path = this.url + this.basePath + '/correlations';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (timestamp !== undefined) {
            queryParameters['timestamp'] = timestamp;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (correlation !== undefined) {
            queryParameters['correlation'] = correlation;
        }

        if (causeId !== undefined) {
            queryParameters['cause_id'] = causeId;
        }

        if (effectId !== undefined) {
            queryParameters['effect_id'] = effectId;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (numberOfPairs !== undefined) {
            queryParameters['number_of_pairs'] = numberOfPairs;
        }

        if (valuePredictingHighOutcome !== undefined) {
            queryParameters['value_predicting_high_outcome'] = valuePredictingHighOutcome;
        }

        if (valuePredictingLowOutcome !== undefined) {
            queryParameters['value_predicting_low_outcome'] = valuePredictingLowOutcome;
        }

        if (optimalPearsonProduct !== undefined) {
            queryParameters['optimal_pearson_product'] = optimalPearsonProduct;
        }

        if (vote !== undefined) {
            queryParameters['vote'] = vote;
        }

        if (statisticalSignificance !== undefined) {
            queryParameters['statistical_significance'] = statisticalSignificance;
        }

        if (causeUnit !== undefined) {
            queryParameters['cause_unit'] = causeUnit;
        }

        if (causeUnitId !== undefined) {
            queryParameters['cause_unit_id'] = causeUnitId;
        }

        if (causeChanges !== undefined) {
            queryParameters['cause_changes'] = causeChanges;
        }

        if (effectChanges !== undefined) {
            queryParameters['effect_changes'] = effectChanges;
        }

        if (qmScore !== undefined) {
            queryParameters['qm_score'] = qmScore;
        }

        if (error !== undefined) {
            queryParameters['error'] = error;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (reversePearsonCorrelationCoefficient !== undefined) {
            queryParameters['reverse_pearson_correlation_coefficient'] = reversePearsonCorrelationCoefficient;
        }

        if (predictivePearsonCorrelationCoefficient !== undefined) {
            queryParameters['predictive_pearson_correlation_coefficient'] = predictivePearsonCorrelationCoefficient;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_7;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public correlationsPost (body?: Correlation) : Promise<{ response: http.ClientResponse; body: inline_response_200_8;  }> {
        const path = this.url + this.basePath + '/correlations';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_8;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public correlationsIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_8;  }> {
        const path = this.url + this.basePath + '/correlations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling correlationsIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_8;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public correlationsIdPut (id: number, body?: Correlation) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/correlations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling correlationsIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public correlationsIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/correlations/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling correlationsIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class ConnectionApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public connectionsGet (userId?: number, connectorId?: number, connectStatus?: string, connectError?: string, updateRequestedAt?: string, updateStatus?: string, updateError?: string, lastSuccessfulUpdatedAt?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_3;  }> {
        const path = this.url + this.basePath + '/connections';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (connectStatus !== undefined) {
            queryParameters['connect_status'] = connectStatus;
        }

        if (connectError !== undefined) {
            queryParameters['connect_error'] = connectError;
        }

        if (updateRequestedAt !== undefined) {
            queryParameters['update_requested_at'] = updateRequestedAt;
        }

        if (updateStatus !== undefined) {
            queryParameters['update_status'] = updateStatus;
        }

        if (updateError !== undefined) {
            queryParameters['update_error'] = updateError;
        }

        if (lastSuccessfulUpdatedAt !== undefined) {
            queryParameters['last_successful_updated_at'] = lastSuccessfulUpdatedAt;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_3;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public connectionsPost (body?: Connection) : Promise<{ response: http.ClientResponse; body: inline_response_200_4;  }> {
        const path = this.url + this.basePath + '/connections';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_4;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public connectionsIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_4;  }> {
        const path = this.url + this.basePath + '/connections/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectionsIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_4;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public connectionsIdPut (id: number, body?: Connection) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/connections/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectionsIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public connectionsIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/connections/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling connectionsIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.quantimodo_oauth2.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class UnitApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public unitsGet (clientId?: string, name?: string, abbreviatedName?: string, categoryId?: boolean, minimumValue?: number, maximumValue?: number, updated?: number, multiply?: number, add?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_17;  }> {
        const path = this.url + this.basePath + '/units';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (abbreviatedName !== undefined) {
            queryParameters['abbreviated_name'] = abbreviatedName;
        }

        if (categoryId !== undefined) {
            queryParameters['category_id'] = categoryId;
        }

        if (minimumValue !== undefined) {
            queryParameters['minimum_value'] = minimumValue;
        }

        if (maximumValue !== undefined) {
            queryParameters['maximum_value'] = maximumValue;
        }

        if (updated !== undefined) {
            queryParameters['updated'] = updated;
        }

        if (multiply !== undefined) {
            queryParameters['multiply'] = multiply;
        }

        if (add !== undefined) {
            queryParameters['add'] = add;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_17;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public unitsPost (body?: Unit) : Promise<{ response: http.ClientResponse; body: inline_response_200_18;  }> {
        const path = this.url + this.basePath + '/units';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_18;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public unitsIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_18;  }> {
        const path = this.url + this.basePath + '/units/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitsIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_18;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public unitsIdPut (id: number, body?: Unit) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/units/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitsIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public unitsIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/units/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitsIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class UserVariableApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public userVariablesGet (clientId?: string, variableId?: number, defaultUnitId?: number, minimumAllowedValue?: number, maximumAllowedValue?: number, fillingValue?: number, joinWith?: number, onsetDelay?: number, durationOfAction?: number, variableCategoryId?: number, updated?: number, _public?: number, causeOnly?: boolean, fillingType?: string, numberOfMeasurements?: number, numberOfProcessedMeasurements?: number, measurementsAtLastAnalysis?: number, lastUnitId?: number, lastOriginalUnitId?: number, lastOriginalValue?: number, lastValue?: number, lastSourceId?: number, numberOfCorrelations?: number, status?: string, errorMessage?: string, lastSuccessfulUpdateTime?: string, standardDeviation?: number, variance?: number, minimumRecordedDailyValue?: number, maximumRecordedDailyValue?: number, mean?: number, median?: number, mostCommonUnitId?: number, mostCommonValue?: number, numberOfUniqueDailyValues?: number, numberOfChanges?: number, skewness?: number, kurtosis?: number, latitude?: number, longitude?: number, location?: string, createdAt?: string, updatedAt?: string, outcome?: boolean, sources?: string, earliestSourceTime?: number, latestSourceTime?: number, earliestMeasurementTime?: number, latestMeasurementTime?: number, earliestFillingTime?: number, latestFillingTime?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_21;  }> {
        const path = this.url + this.basePath + '/userVariables';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (variableId !== undefined) {
            queryParameters['variable_id'] = variableId;
        }

        if (defaultUnitId !== undefined) {
            queryParameters['default_unit_id'] = defaultUnitId;
        }

        if (minimumAllowedValue !== undefined) {
            queryParameters['minimum_allowed_value'] = minimumAllowedValue;
        }

        if (maximumAllowedValue !== undefined) {
            queryParameters['maximum_allowed_value'] = maximumAllowedValue;
        }

        if (fillingValue !== undefined) {
            queryParameters['filling_value'] = fillingValue;
        }

        if (joinWith !== undefined) {
            queryParameters['join_with'] = joinWith;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (variableCategoryId !== undefined) {
            queryParameters['variable_category_id'] = variableCategoryId;
        }

        if (updated !== undefined) {
            queryParameters['updated'] = updated;
        }

        if (_public !== undefined) {
            queryParameters['public'] = _public;
        }

        if (causeOnly !== undefined) {
            queryParameters['cause_only'] = causeOnly;
        }

        if (fillingType !== undefined) {
            queryParameters['filling_type'] = fillingType;
        }

        if (numberOfMeasurements !== undefined) {
            queryParameters['number_of_measurements'] = numberOfMeasurements;
        }

        if (numberOfProcessedMeasurements !== undefined) {
            queryParameters['number_of_processed_measurements'] = numberOfProcessedMeasurements;
        }

        if (measurementsAtLastAnalysis !== undefined) {
            queryParameters['measurements_at_last_analysis'] = measurementsAtLastAnalysis;
        }

        if (lastUnitId !== undefined) {
            queryParameters['last_unit_id'] = lastUnitId;
        }

        if (lastOriginalUnitId !== undefined) {
            queryParameters['last_original_unit_id'] = lastOriginalUnitId;
        }

        if (lastOriginalValue !== undefined) {
            queryParameters['last_original_value'] = lastOriginalValue;
        }

        if (lastValue !== undefined) {
            queryParameters['last_value'] = lastValue;
        }

        if (lastSourceId !== undefined) {
            queryParameters['last_source_id'] = lastSourceId;
        }

        if (numberOfCorrelations !== undefined) {
            queryParameters['number_of_correlations'] = numberOfCorrelations;
        }

        if (status !== undefined) {
            queryParameters['status'] = status;
        }

        if (errorMessage !== undefined) {
            queryParameters['error_message'] = errorMessage;
        }

        if (lastSuccessfulUpdateTime !== undefined) {
            queryParameters['last_successful_update_time'] = lastSuccessfulUpdateTime;
        }

        if (standardDeviation !== undefined) {
            queryParameters['standard_deviation'] = standardDeviation;
        }

        if (variance !== undefined) {
            queryParameters['variance'] = variance;
        }

        if (minimumRecordedDailyValue !== undefined) {
            queryParameters['minimum_recorded_daily_value'] = minimumRecordedDailyValue;
        }

        if (maximumRecordedDailyValue !== undefined) {
            queryParameters['maximum_recorded_daily_value'] = maximumRecordedDailyValue;
        }

        if (mean !== undefined) {
            queryParameters['mean'] = mean;
        }

        if (median !== undefined) {
            queryParameters['median'] = median;
        }

        if (mostCommonUnitId !== undefined) {
            queryParameters['most_common_unit_id'] = mostCommonUnitId;
        }

        if (mostCommonValue !== undefined) {
            queryParameters['most_common_value'] = mostCommonValue;
        }

        if (numberOfUniqueDailyValues !== undefined) {
            queryParameters['number_of_unique_daily_values'] = numberOfUniqueDailyValues;
        }

        if (numberOfChanges !== undefined) {
            queryParameters['number_of_changes'] = numberOfChanges;
        }

        if (skewness !== undefined) {
            queryParameters['skewness'] = skewness;
        }

        if (kurtosis !== undefined) {
            queryParameters['kurtosis'] = kurtosis;
        }

        if (latitude !== undefined) {
            queryParameters['latitude'] = latitude;
        }

        if (longitude !== undefined) {
            queryParameters['longitude'] = longitude;
        }

        if (location !== undefined) {
            queryParameters['location'] = location;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (outcome !== undefined) {
            queryParameters['outcome'] = outcome;
        }

        if (sources !== undefined) {
            queryParameters['sources'] = sources;
        }

        if (earliestSourceTime !== undefined) {
            queryParameters['earliest_source_time'] = earliestSourceTime;
        }

        if (latestSourceTime !== undefined) {
            queryParameters['latest_source_time'] = latestSourceTime;
        }

        if (earliestMeasurementTime !== undefined) {
            queryParameters['earliest_measurement_time'] = earliestMeasurementTime;
        }

        if (latestMeasurementTime !== undefined) {
            queryParameters['latest_measurement_time'] = latestMeasurementTime;
        }

        if (earliestFillingTime !== undefined) {
            queryParameters['earliest_filling_time'] = earliestFillingTime;
        }

        if (latestFillingTime !== undefined) {
            queryParameters['latest_filling_time'] = latestFillingTime;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_21;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public userVariablesPost (body?: UserVariable) : Promise<{ response: http.ClientResponse; body: inline_response_200_22;  }> {
        const path = this.url + this.basePath + '/userVariables';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_22;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public userVariablesIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_22;  }> {
        const path = this.url + this.basePath + '/userVariables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling userVariablesIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_22;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public userVariablesIdPut (id: number, body?: UserVariable) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/userVariables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling userVariablesIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public userVariablesIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/userVariables/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling userVariablesIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class SourceApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public sourcesGet (clientId?: string, name?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_13;  }> {
        const path = this.url + this.basePath + '/sources';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_13;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public sourcesPost (body?: Source) : Promise<{ response: http.ClientResponse; body: inline_response_200_14;  }> {
        const path = this.url + this.basePath + '/sources';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_14;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public sourcesIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_14;  }> {
        const path = this.url + this.basePath + '/sources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling sourcesIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_14;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public sourcesIdPut (id: number, body?: Source) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/sources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling sourcesIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public sourcesIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/sources/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling sourcesIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class VariableCategoryApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public variableCategoriesGet (name?: string, fillingValue?: number, maximumAllowedValue?: number, minimumAllowedValue?: number, durationOfAction?: number, onsetDelay?: number, combinationOperation?: string, updated?: number, causeOnly?: boolean, _public?: number, outcome?: boolean, createdAt?: string, updatedAt?: string, imageUrl?: string, defaultUnitId?: number, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_23;  }> {
        const path = this.url + this.basePath + '/variableCategories';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (fillingValue !== undefined) {
            queryParameters['filling_value'] = fillingValue;
        }

        if (maximumAllowedValue !== undefined) {
            queryParameters['maximum_allowed_value'] = maximumAllowedValue;
        }

        if (minimumAllowedValue !== undefined) {
            queryParameters['minimum_allowed_value'] = minimumAllowedValue;
        }

        if (durationOfAction !== undefined) {
            queryParameters['duration_of_action'] = durationOfAction;
        }

        if (onsetDelay !== undefined) {
            queryParameters['onset_delay'] = onsetDelay;
        }

        if (combinationOperation !== undefined) {
            queryParameters['combination_operation'] = combinationOperation;
        }

        if (updated !== undefined) {
            queryParameters['updated'] = updated;
        }

        if (causeOnly !== undefined) {
            queryParameters['cause_only'] = causeOnly;
        }

        if (_public !== undefined) {
            queryParameters['public'] = _public;
        }

        if (outcome !== undefined) {
            queryParameters['outcome'] = outcome;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (imageUrl !== undefined) {
            queryParameters['image_url'] = imageUrl;
        }

        if (defaultUnitId !== undefined) {
            queryParameters['default_unit_id'] = defaultUnitId;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_23;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variableCategoriesPost (body?: VariableCategory) : Promise<{ response: http.ClientResponse; body: inline_response_200_24;  }> {
        const path = this.url + this.basePath + '/variableCategories';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_24;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variableCategoriesIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_24;  }> {
        const path = this.url + this.basePath + '/variableCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableCategoriesIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_24;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variableCategoriesIdPut (id: number, body?: VariableCategory) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/variableCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableCategoriesIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public variableCategoriesIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/variableCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling variableCategoriesIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class CredentialApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public credentialsGet (connectorId?: boolean, attrKey?: string, attrValue?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_9;  }> {
        const path = this.url + this.basePath + '/credentials';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (connectorId !== undefined) {
            queryParameters['connector_id'] = connectorId;
        }

        if (attrKey !== undefined) {
            queryParameters['attr_key'] = attrKey;
        }

        if (attrValue !== undefined) {
            queryParameters['attr_value'] = attrValue;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_9;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public credentialsPost (body?: Credential) : Promise<{ response: http.ClientResponse; body: inline_response_200_10;  }> {
        const path = this.url + this.basePath + '/credentials';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_10;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public credentialsIdGet (id: number, attrKey: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_10;  }> {
        const path = this.url + this.basePath + '/credentials/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling credentialsIdGet');
        }

        // verify required parameter 'attrKey' is set
        if (!attrKey) {
            throw new Error('Missing required parameter attrKey when calling credentialsIdGet');
        }

        if (attrKey !== undefined) {
            queryParameters['attrKey'] = attrKey;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_10;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public credentialsIdPut (id: number, attrKey: string, body?: Credential) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/credentials/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling credentialsIdPut');
        }

        // verify required parameter 'attrKey' is set
        if (!attrKey) {
            throw new Error('Missing required parameter attrKey when calling credentialsIdPut');
        }

        if (attrKey !== undefined) {
            queryParameters['attrKey'] = attrKey;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public credentialsIdDelete (id: number, attrKey: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/credentials/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling credentialsIdDelete');
        }

        // verify required parameter 'attrKey' is set
        if (!attrKey) {
            throw new Error('Missing required parameter attrKey when calling credentialsIdDelete');
        }

        if (attrKey !== undefined) {
            queryParameters['attrKey'] = attrKey;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class UnitCategoryApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public unitCategoriesGet (name?: string, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_15;  }> {
        const path = this.url + this.basePath + '/unitCategories';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_15;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public unitCategoriesPost (body?: UnitCategory) : Promise<{ response: http.ClientResponse; body: inline_response_200_16;  }> {
        const path = this.url + this.basePath + '/unitCategories';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_16;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public unitCategoriesIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_16;  }> {
        const path = this.url + this.basePath + '/unitCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitCategoriesIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_16;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public unitCategoriesIdPut (id: number, body?: UnitCategory) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/unitCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitCategoriesIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public unitCategoriesIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/unitCategories/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling unitCategoriesIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
export class VoteApi {
    protected basePath = 'https://app.quantimo.do/api/v2';
    protected defaultHeaders : any = {};



    public authentications = {
        'default': <Authentication>new VoidAuth(),
        'quantimodo_oauth2': new OAuth(),
    }

    constructor(url: string, basePath?: string);
    constructor(private url: string, basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                objA[key] = objB[key];
            }
        }
        return <T1&T2>objA;
    }

    public votesGet (clientId?: string, userId?: number, causeId?: number, effectId?: number, value?: number, createdAt?: string, updatedAt?: string, limit?: number, offset?: number, sort?: string) : Promise<{ response: http.ClientResponse; body: inline_response_200_29;  }> {
        const path = this.url + this.basePath + '/votes';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        if (clientId !== undefined) {
            queryParameters['client_id'] = clientId;
        }

        if (userId !== undefined) {
            queryParameters['user_id'] = userId;
        }

        if (causeId !== undefined) {
            queryParameters['cause_id'] = causeId;
        }

        if (effectId !== undefined) {
            queryParameters['effect_id'] = effectId;
        }

        if (value !== undefined) {
            queryParameters['value'] = value;
        }

        if (createdAt !== undefined) {
            queryParameters['created_at'] = createdAt;
        }

        if (updatedAt !== undefined) {
            queryParameters['updated_at'] = updatedAt;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (offset !== undefined) {
            queryParameters['offset'] = offset;
        }

        if (sort !== undefined) {
            queryParameters['sort'] = sort;
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_29;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public votesPost (body?: Vote) : Promise<{ response: http.ClientResponse; body: inline_response_200_30;  }> {
        const path = this.url + this.basePath + '/votes';
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_30;  }>();

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public votesIdGet (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_30;  }> {
        const path = this.url + this.basePath + '/votes/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling votesIdGet');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_30;  }>();

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public votesIdPut (id: number, body?: Vote) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/votes/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling votesIdPut');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
            body: body,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }

    public votesIdDelete (id: number) : Promise<{ response: http.ClientResponse; body: inline_response_200_2;  }> {
        const path = this.url + this.basePath + '/votes/{id}'
            .replace('{' + 'id' + '}', String(id));
        let queryParameters: any = {};
        let headerParams: any = this.extendObj({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'id' is set
        if (!id) {
            throw new Error('Missing required parameter id when calling votesIdDelete');
        }

        let useFormData = false;

        let deferred = promise.defer<{ response: http.ClientResponse; body: inline_response_200_2;  }>();

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: path,
            json: true,
        }

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }

        request(requestOptions, (error, response, body) => {
            if (error) {
                deferred.reject(error);
            } else {
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    deferred.resolve({ response: response, body: body });
                } else {
                    deferred.reject({ response: response, body: body });
                }
            }
        });

        return deferred.promise;
    }
}
